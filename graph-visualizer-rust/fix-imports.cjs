#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

class ImportFixer {
    constructor() {
        this.fixes = [];
        this.wrapperTemplates = {
            umd: (moduleName, globalName) => `// ES Module wrapper for ${moduleName}
// Auto-generated by fix-imports.js

// Import the UMD module
import './${moduleName}';

// Handle both browser and web worker contexts
const globalObj = typeof window !== 'undefined' ? window : 
                 typeof self !== 'undefined' ? self : 
                 typeof global !== 'undefined' ? global : {};

// Get the exported value
const ${globalName} = globalObj.${globalName};

if (!${globalName}) {
    console.warn('${moduleName}: ${globalName} not found on global object');
}

// Export as default
export default ${globalName};

// Also export as named export
export { ${globalName} };
`,
            commonjs: (moduleName) => `// ES Module wrapper for CommonJS module
// Auto-generated by fix-imports.js

// For CommonJS modules in the browser, we need to handle them differently
const module = { exports: {} };
const exports = module.exports;

// Import and execute the CommonJS module
import('./${moduleName}');

// Export the result
export default module.exports;
`
        };
    }

    // Check if a module needs a wrapper
    checkModuleNeedsWrapper(modulePath) {
        if (!fs.existsSync(modulePath)) return false;
        
        const content = fs.readFileSync(modulePath, 'utf8');
        
        // Check for UMD pattern
        const hasUMD = /typeof exports === ['"]object['"]/.test(content) &&
                      /typeof define === ['"]function['"]/.test(content);
        
        // Check for CommonJS
        const hasCommonJS = /module\.exports\s*=/.test(content) ||
                           /exports\.\w+\s*=/.test(content);
        
        // Check if already has ES module exports
        const hasESExports = /export\s+(default|{)/.test(content);
        
        return (hasUMD || hasCommonJS) && !hasESExports;
    }

    // Extract global variable name from UMD module
    extractGlobalName(modulePath) {
        const content = fs.readFileSync(modulePath, 'utf8');
        
        // Common patterns for UMD global assignment
        const patterns = [
            /global\.(\w+)\s*=\s*factory/,
            /root\.(\w+)\s*=\s*factory/,
            /window\.(\w+)\s*=\s*factory/,
            /this\.(\w+)\s*=\s*factory/,
            /\(([^,]+),\s*factory\)\s*;/
        ];
        
        for (const pattern of patterns) {
            const match = content.match(pattern);
            if (match) {
                return match[1].replace(/['"]/g, '').trim();
            }
        }
        
        // Fallback: use filename
        return path.basename(modulePath, '.js');
    }

    // Create a wrapper for a module
    createWrapper(modulePath, wrapperPath) {
        const moduleName = path.basename(modulePath);
        const content = fs.readFileSync(modulePath, 'utf8');
        
        let wrapperContent;
        
        if (/typeof exports === ['"]object['"]/.test(content)) {
            // UMD module
            const globalName = this.extractGlobalName(modulePath);
            wrapperContent = this.wrapperTemplates.umd(moduleName, globalName);
        } else {
            // CommonJS module
            wrapperContent = this.wrapperTemplates.commonjs(moduleName);
        }
        
        fs.writeFileSync(wrapperPath, wrapperContent);
        this.fixes.push({
            type: 'wrapper_created',
            file: wrapperPath,
            forModule: modulePath
        });
        
        console.log(`✓ Created wrapper: ${wrapperPath}`);
    }

    // Update import map in HTML
    updateImportMap(htmlPath, newMappings) {
        let content = fs.readFileSync(htmlPath, 'utf8');
        const importMapMatch = content.match(/(<script\s+type="importmap"[^>]*>)([\s\S]*?)(<\/script>)/i);
        
        if (importMapMatch) {
            try {
                const importMapJson = importMapMatch[2];
                const importMap = JSON.parse(importMapJson);
                
                // Add new mappings
                Object.assign(importMap.imports, newMappings);
                
                // Sort imports alphabetically for consistency
                const sortedImports = {};
                Object.keys(importMap.imports).sort().forEach(key => {
                    sortedImports[key] = importMap.imports[key];
                });
                importMap.imports = sortedImports;
                
                // Replace import map in HTML
                const newImportMapJson = JSON.stringify(importMap, null, 8)
                    .split('\n')
                    .map((line, i) => i === 0 ? line : '    ' + line)
                    .join('\n');
                
                content = content.replace(
                    importMapMatch[0],
                    `${importMapMatch[1]}\n    ${newImportMapJson}\n    ${importMapMatch[3]}`
                );
                
                fs.writeFileSync(htmlPath, content);
                
                this.fixes.push({
                    type: 'import_map_updated',
                    file: htmlPath,
                    mappings: newMappings
                });
                
                console.log(`✓ Updated import map in ${htmlPath}`);
                
            } catch (e) {
                console.error(`Failed to update import map: ${e.message}`);
            }
        }
    }

    // Fix missing data URL stubs
    createDataUrlStub(importPath) {
        const stubContent = {
            'supabase': 'export function createClient() { return { from: () => ({ insert: async () => ({ error: null }) }) }; }',
            'inject-css': 'export default function() {}',
            'ResizeObserver': 'export class ResizeObserver { observe() {} unobserve() {} disconnect() {} }',
            'ResizeObserverController': 'export class ResizeObserverController {}'
        };
        
        for (const [key, value] of Object.entries(stubContent)) {
            if (importPath.includes(key)) {
                return `data:text/javascript,${encodeURIComponent(value)}`;
            }
        }
        
        return `data:text/javascript,export default {}`;
    }

    // Main fix routine
    async fix() {
        console.log('🔧 Auto-fixing import issues...\n');
        
        const vendorDir = path.join(__dirname, 'static', 'vendor');
        const htmlPath = path.join(__dirname, 'static', 'cosmograph.html');
        
        // 1. Check for modules that need wrappers
        console.log('1. Checking for modules that need ES module wrappers...');
        const modulesToWrap = [
            { module: 'crossfilter2/crossfilter.js', wrapper: 'crossfilter2-es-wrapper.js', global: 'crossfilter' },
            { module: 'dompurify/dist/purify.js', wrapper: 'dompurify-es-wrapper.js', global: 'DOMPurify' },
            { module: 'gl-bench/dist/gl-bench.js', wrapper: 'gl-bench-es-wrapper.js', global: 'GLBench' }
        ];
        
        for (const { module, wrapper, global } of modulesToWrap) {
            const modulePath = path.join(vendorDir, module);
            const wrapperPath = path.join(vendorDir, wrapper);
            
            if (fs.existsSync(modulePath) && !fs.existsSync(wrapperPath)) {
                if (this.checkModuleNeedsWrapper(modulePath)) {
                    this.createWrapper(modulePath, wrapperPath);
                }
            }
        }
        
        // 2. Fix import map
        console.log('\n2. Checking import map for missing entries...');
        const newMappings = {};
        
        // Add missing data URL stubs
        const dataUrlImports = [
            '@supabase/supabase-js',
            './../../ext/rollup-plugin-styles/dist/runtime/inject-css.js'
        ];
        
        for (const imp of dataUrlImports) {
            newMappings[imp] = this.createDataUrlStub(imp);
        }
        
        if (Object.keys(newMappings).length > 0) {
            this.updateImportMap(htmlPath, newMappings);
        }
        
        // 3. Validate wrapper consistency
        console.log('\n3. Validating wrapper consistency...');
        const wrapperFiles = fs.readdirSync(vendorDir).filter(f => f.includes('wrapper'));
        
        for (const wrapper of wrapperFiles) {
            const wrapperPath = path.join(vendorDir, wrapper);
            const content = fs.readFileSync(wrapperPath, 'utf8');
            
            // Check for proper error handling
            if (!content.includes('if (!') && !content.includes('console.warn')) {
                console.log(`⚠️  ${wrapper} lacks error handling`);
            }
            
            // Check for web worker compatibility
            if (!content.includes('typeof self')) {
                console.log(`⚠️  ${wrapper} may not work in web workers`);
            }
        }
        
        // Generate report
        console.log('\n' + '='.repeat(60));
        console.log('FIX SUMMARY');
        console.log('='.repeat(60));
        console.log(`Total fixes applied: ${this.fixes.length}`);
        
        if (this.fixes.length > 0) {
            console.log('\nFixes applied:');
            for (const fix of this.fixes) {
                console.log(`  - ${fix.type}: ${fix.file}`);
                if (fix.mappings) {
                    for (const [key, value] of Object.entries(fix.mappings)) {
                        console.log(`    ${key} -> ${value.substring(0, 50)}...`);
                    }
                }
            }
        }
        
        console.log('\n✅ Import fixes complete!');
        console.log('\nRun "node validate-imports.js" to verify all imports are now valid.');
    }
}

// Main execution
if (require.main === module) {
    const fixer = new ImportFixer();
    fixer.fix().catch(console.error);
}

module.exports = ImportFixer;