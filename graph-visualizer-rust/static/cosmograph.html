<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FalkorDB Cosmograph GPU-Accelerated Visualizer</title>
    <script type="importmap">
    {
        "imports": {
            "@cosmograph/cosmograph": "/vendor/index.js",
            "@cosmograph/cosmos": "/vendor/cosmos/dist/index.js",
            "@ranfdev/deepobj": "/vendor/deepobj/dist/deepobj.m.js",
            "regl": "/vendor/regl-wrapper.js",
            "gl-matrix": "/vendor/gl-matrix/esm/index.js",
            "gl-matrix/mat2": "/vendor/gl-matrix/esm/mat2.js",
            "gl-matrix/mat2d": "/vendor/gl-matrix/esm/mat2d.js",
            "gl-matrix/mat3": "/vendor/gl-matrix/esm/mat3.js",
            "gl-matrix/mat4": "/vendor/gl-matrix/esm/mat4.js",
            "gl-matrix/quat": "/vendor/gl-matrix/esm/quat.js",
            "gl-matrix/quat2": "/vendor/gl-matrix/esm/quat2.js",
            "gl-matrix/vec2": "/vendor/gl-matrix/esm/vec2.js",
            "gl-matrix/vec3": "/vendor/gl-matrix/esm/vec3.js",
            "gl-matrix/vec4": "/vendor/gl-matrix/esm/vec4.js",
            "gl-matrix/common": "/vendor/gl-matrix/esm/common.js",
            "random": "/vendor/random/dist/index.js",
            "d3-zoom": "/vendor/d3-zoom/src/index.js",
            "./zoom.js": "/vendor/d3-zoom/src/zoom.js",
            "./transform.js": "/vendor/d3-zoom/src/transform.js",
            "./noevent.js": "/vendor/d3-zoom/src/noevent.js",
            "./event.js": "/vendor/d3-zoom/src/event.js",
            "./constant.js": "/vendor/d3-zoom/src/constant.js",
            "d3-drag": "/vendor/d3-drag/src/index.js",
            "./drag.js": "/vendor/d3-drag/src/drag.js",
            "./nodrag.js": "/vendor/d3-drag/src/nodrag.js",
            "dompurify": "/vendor/dompurify/dist/purify.es.mjs",
            "gl-bench": "/vendor/gl-bench/dist/gl-bench.module.js",
            "@interacta/css-labels": "/vendor/interacta-css-labels/dist/index.js",
            "@cosmograph/ui": "/vendor/cosmograph-ui/index.js",
            "@juggle/resize-observer": "/vendor/juggle-resize-observer-bundled.js",
            "./ResizeObserverController": "/vendor/juggle-resize-observer-bundled.js",
            "./utils/element": "/vendor/juggle-resize-observer-bundled.js",
            "d3-color": "/vendor/d3-color/src/index.js",
            "./color.js": "/vendor/d3-color/src/color.js",
            "./cubehelix.js": "/vendor/d3-color/src/cubehelix.js",
            "./define.js": "/vendor/d3-color/src/define.js",
            "./lab.js": "/vendor/d3-color/src/lab.js",
            "./math.js": "/vendor/d3-color/src/math.js",
            "d3-transition": "/vendor/d3-transition/src/index.js",
            "./transition/index.js": "/vendor/d3-transition/src/transition/index.js",
            "./active.js": "/vendor/d3-transition/src/active.js",
            "./interrupt.js": "/vendor/d3-transition/src/interrupt.js",
            "./selection/index.js": "/vendor/d3-transition/src/selection/index.js",
            "./transition/attr.js": "/vendor/d3-transition/src/transition/attr.js",
            "./transition/attrTween.js": "/vendor/d3-transition/src/transition/attrTween.js",
            "./transition/delay.js": "/vendor/d3-transition/src/transition/delay.js",
            "./transition/duration.js": "/vendor/d3-transition/src/transition/duration.js",
            "./transition/ease.js": "/vendor/d3-transition/src/transition/ease.js",
            "./transition/filter.js": "/vendor/d3-transition/src/transition/filter.js",
            "./transition/merge.js": "/vendor/d3-transition/src/transition/merge.js",
            "./transition/on.js": "/vendor/d3-transition/src/transition/on.js",
            "./transition/remove.js": "/vendor/d3-transition/src/transition/remove.js",
            "./transition/select.js": "/vendor/d3-transition/src/transition/select.js",
            "./transition/selectAll.js": "/vendor/d3-transition/src/transition/selectAll.js",
            "./transition/selection.js": "/vendor/d3-transition/src/transition/selection.js",
            "./transition/style.js": "/vendor/d3-transition/src/transition/style.js",
            "./transition/styleTween.js": "/vendor/d3-transition/src/transition/styleTween.js",
            "./transition/text.js": "/vendor/d3-transition/src/transition/text.js",
            "./transition/textTween.js": "/vendor/d3-transition/src/transition/textTween.js",
            "./transition/transition.js": "/vendor/d3-transition/src/transition/transition.js",
            "./transition/tween.js": "/vendor/d3-transition/src/transition/tween.js",
            "./transition/end.js": "/vendor/d3-transition/src/transition/end.js",
            "./transition/schedule.js": "/vendor/d3-transition/src/transition/schedule.js",
            "./selection/interrupt.js": "/vendor/d3-transition/src/selection/interrupt.js",
            "./selection/transition.js": "/vendor/d3-transition/src/selection/transition.js",
            "d3-dispatch": "/vendor/d3-dispatch/src/index.js",
            "./dispatch.js": "/vendor/d3-dispatch/src/dispatch.js",
            "d3-ease": "/vendor/d3-ease/src/index.js",
            "./linear.js": "/vendor/d3-ease/src/linear.js",
            "./quad.js": "/vendor/d3-ease/src/quad.js",
            "./cubic.js": "/vendor/d3-ease/src/cubic.js",
            "./poly.js": "/vendor/d3-ease/src/poly.js",
            "./sin.js": "/vendor/d3-ease/src/sin.js",
            "./exp.js": "/vendor/d3-ease/src/exp.js",
            "./circle.js": "/vendor/d3-ease/src/circle.js",
            "./bounce.js": "/vendor/d3-ease/src/bounce.js",
            "./back.js": "/vendor/d3-ease/src/back.js",
            "./elastic.js": "/vendor/d3-ease/src/elastic.js",
            "d3-interpolate": "/vendor/d3-interpolate/src/index.js",
            "./value.js": "/vendor/d3-interpolate/src/value.js",
            "./array.js": "/vendor/d3-interpolate/src/array.js",
            "./basis.js": "/vendor/d3-interpolate/src/basis.js",
            "./basisClosed.js": "/vendor/d3-interpolate/src/basisClosed.js",
            "./color.js": "/vendor/d3-interpolate/src/color.js",
            "./constant.js": "/vendor/d3-interpolate/src/constant.js",
            "./cubehelix.js": "/vendor/d3-interpolate/src/cubehelix.js",
            "./date.js": "/vendor/d3-interpolate/src/date.js",
            "./discrete.js": "/vendor/d3-interpolate/src/discrete.js",
            "./hcl.js": "/vendor/d3-interpolate/src/hcl.js",
            "./hsl.js": "/vendor/d3-interpolate/src/hsl.js",
            "./hue.js": "/vendor/d3-interpolate/src/hue.js",
            "./lab.js": "/vendor/d3-interpolate/src/lab.js",
            "./number.js": "/vendor/d3-interpolate/src/number.js",
            "./numberArray.js": "/vendor/d3-interpolate/src/numberArray.js",
            "./object.js": "/vendor/d3-interpolate/src/object.js",
            "./piecewise.js": "/vendor/d3-interpolate/src/piecewise.js",
            "./quantize.js": "/vendor/d3-interpolate/src/quantize.js",
            "./rgb.js": "/vendor/d3-interpolate/src/rgb.js",
            "./round.js": "/vendor/d3-interpolate/src/round.js",
            "./string.js": "/vendor/d3-interpolate/src/string.js",
            "./transform/index.js": "/vendor/d3-interpolate/src/transform/index.js",
            "./transform/decompose.js": "/vendor/d3-interpolate/src/transform/decompose.js",
            "./transform/parse.js": "/vendor/d3-interpolate/src/transform/parse.js",
            "./zoom.js": "/vendor/d3-interpolate/src/zoom.js",
            "d3-timer": "/vendor/d3-timer/src/index.js",
            "./timer.js": "/vendor/d3-timer/src/timer.js",
            "./timeout.js": "/vendor/d3-timer/src/timeout.js",
            "./interval.js": "/vendor/d3-timer/src/interval.js",
            "d3-selection": "/vendor/d3-selection/src/index.js",
            "./create.js": "/vendor/d3-selection/src/create.js",
            "./creator.js": "/vendor/d3-selection/src/creator.js",
            "./local.js": "/vendor/d3-selection/src/local.js",
            "./matcher.js": "/vendor/d3-selection/src/matcher.js",
            "./namespace.js": "/vendor/d3-selection/src/namespace.js",
            "./namespaces.js": "/vendor/d3-selection/src/namespaces.js",
            "./pointer.js": "/vendor/d3-selection/src/pointer.js",
            "./pointers.js": "/vendor/d3-selection/src/pointers.js",
            "./select.js": "/vendor/d3-selection/src/select.js",
            "./selectAll.js": "/vendor/d3-selection/src/selectAll.js",
            "./selection/index.js": "/vendor/d3-selection/src/selection/index.js",
            "./selector.js": "/vendor/d3-selection/src/selector.js",
            "./selectorAll.js": "/vendor/d3-selection/src/selectorAll.js",
            "./selection/style.js": "/vendor/d3-selection/src/selection/style.js",
            "./window.js": "/vendor/d3-selection/src/window.js",
            "./sourceEvent.js": "/vendor/d3-selection/src/sourceEvent.js",
            "./selection/append.js": "/vendor/d3-selection/src/selection/append.js",
            "./selection/attr.js": "/vendor/d3-selection/src/selection/attr.js",
            "./selection/call.js": "/vendor/d3-selection/src/selection/call.js",
            "./selection/classed.js": "/vendor/d3-selection/src/selection/classed.js",
            "./selection/clone.js": "/vendor/d3-selection/src/selection/clone.js",
            "./selection/data.js": "/vendor/d3-selection/src/selection/data.js",
            "./selection/datum.js": "/vendor/d3-selection/src/selection/datum.js",
            "./selection/dispatch.js": "/vendor/d3-selection/src/selection/dispatch.js",
            "./selection/each.js": "/vendor/d3-selection/src/selection/each.js",
            "./selection/empty.js": "/vendor/d3-selection/src/selection/empty.js",
            "./selection/enter.js": "/vendor/d3-selection/src/selection/enter.js",
            "./selection/exit.js": "/vendor/d3-selection/src/selection/exit.js",
            "./selection/filter.js": "/vendor/d3-selection/src/selection/filter.js",
            "./selection/html.js": "/vendor/d3-selection/src/selection/html.js",
            "./selection/insert.js": "/vendor/d3-selection/src/selection/insert.js",
            "./selection/join.js": "/vendor/d3-selection/src/selection/join.js",
            "./selection/lower.js": "/vendor/d3-selection/src/selection/lower.js",
            "./selection/merge.js": "/vendor/d3-selection/src/selection/merge.js",
            "./selection/node.js": "/vendor/d3-selection/src/selection/node.js",
            "./selection/nodes.js": "/vendor/d3-selection/src/selection/nodes.js",
            "./selection/on.js": "/vendor/d3-selection/src/selection/on.js",
            "./selection/order.js": "/vendor/d3-selection/src/selection/order.js",
            "./selection/property.js": "/vendor/d3-selection/src/selection/property.js",
            "./selection/raise.js": "/vendor/d3-selection/src/selection/raise.js",
            "./selection/remove.js": "/vendor/d3-selection/src/selection/remove.js",
            "./selection/select.js": "/vendor/d3-selection/src/selection/select.js",
            "./selection/selectAll.js": "/vendor/d3-selection/src/selection/selectAll.js",
            "./selection/selectChild.js": "/vendor/d3-selection/src/selection/selectChild.js",
            "./selection/selectChildren.js": "/vendor/d3-selection/src/selection/selectChildren.js",
            "./selection/size.js": "/vendor/d3-selection/src/selection/size.js",
            "./selection/sort.js": "/vendor/d3-selection/src/selection/sort.js",
            "./selection/sparse.js": "/vendor/d3-selection/src/selection/sparse.js",
            "./selection/text.js": "/vendor/d3-selection/src/selection/text.js",
            "./selection/iterator.js": "/vendor/d3-selection/src/selection/iterator.js",
            "./constant.js": "/vendor/d3-selection/src/constant.js",
            "./array.js": "/vendor/d3-selection/src/array.js",
            "d3-array": "/vendor/d3-array/src/index.js",
            "./ascending.js": "/vendor/d3-array/src/ascending.js",
            "./bisector.js": "/vendor/d3-array/src/bisector.js",
            "./bisect.js": "/vendor/d3-array/src/bisect.js",
            "./descending.js": "/vendor/d3-array/src/descending.js",
            "./number.js": "/vendor/d3-array/src/number.js",
            "./extent.js": "/vendor/d3-array/src/extent.js",
            "./identity.js": "/vendor/d3-array/src/identity.js",
            "./range.js": "/vendor/d3-array/src/range.js",
            "./ticks.js": "/vendor/d3-array/src/ticks.js",
            "./threshold/freedmanDiaconis.js": "/vendor/d3-array/src/threshold/freedmanDiaconis.js",
            "./threshold/scott.js": "/vendor/d3-array/src/threshold/scott.js",
            "./threshold/sturges.js": "/vendor/d3-array/src/threshold/sturges.js",
            "./max.js": "/vendor/d3-array/src/max.js",
            "./mean.js": "/vendor/d3-array/src/mean.js",
            "./median.js": "/vendor/d3-array/src/median.js",
            "./merge.js": "/vendor/d3-array/src/merge.js",
            "./min.js": "/vendor/d3-array/src/min.js",
            "./pairs.js": "/vendor/d3-array/src/pairs.js",
            "./permute.js": "/vendor/d3-array/src/permute.js",
            "./quantile.js": "/vendor/d3-array/src/quantile.js",
            "./quickselect.js": "/vendor/d3-array/src/quickselect.js",
            "./scan.js": "/vendor/d3-array/src/scan.js",
            "./shuffle.js": "/vendor/d3-array/src/shuffle.js",
            "./sum.js": "/vendor/d3-array/src/sum.js",
            "./transpose.js": "/vendor/d3-array/src/transpose.js",
            "./variance.js": "/vendor/d3-array/src/variance.js",
            "./zip.js": "/vendor/d3-array/src/zip.js",
            "./cross.js": "/vendor/d3-array/src/cross.js",
            "./cumsum.js": "/vendor/d3-array/src/cumsum.js",
            "./group.js": "/vendor/d3-array/src/group.js",
            "./sort.js": "/vendor/d3-array/src/sort.js",
            "./array.js": "/vendor/d3-array/src/array.js",
            "./constant.js": "/vendor/d3-array/src/constant.js",
            "./nice.js": "/vendor/d3-array/src/nice.js",
            "d3-axis": "/vendor/d3-axis/src/index.js",
            "./axis.js": "/vendor/d3-axis/src/axis.js",
            "./identity.js": "/vendor/d3-axis/src/identity.js",
            "d3-brush": "/vendor/d3-brush/src/index.js",
            "./brush.js": "/vendor/d3-brush/src/brush.js",
            "./noevent.js": "/vendor/d3-brush/src/noevent.js",
            "./event.js": "/vendor/d3-brush/src/event.js",
            "./constant.js": "/vendor/d3-brush/src/constant.js",
            "d3-format": "/vendor/d3-format/src/index.js",
            "./defaultLocale.js": "/vendor/d3-format/src/defaultLocale.js",
            "./exponent.js": "/vendor/d3-format/src/exponent.js",
            "./formatDecimal.js": "/vendor/d3-format/src/formatDecimal.js",
            "./formatGroup.js": "/vendor/d3-format/src/formatGroup.js",
            "./formatNumerals.js": "/vendor/d3-format/src/formatNumerals.js",
            "./formatPrefixAuto.js": "/vendor/d3-format/src/formatPrefixAuto.js",
            "./formatRounded.js": "/vendor/d3-format/src/formatRounded.js",
            "./formatSpecifier.js": "/vendor/d3-format/src/formatSpecifier.js",
            "./formatTrim.js": "/vendor/d3-format/src/formatTrim.js",
            "./formatTypes.js": "/vendor/d3-format/src/formatTypes.js",
            "./locale.js": "/vendor/d3-format/src/locale.js",
            "./precisionFixed.js": "/vendor/d3-format/src/precisionFixed.js",
            "./precisionPrefix.js": "/vendor/d3-format/src/precisionPrefix.js",
            "./precisionRound.js": "/vendor/d3-format/src/precisionRound.js",
            "d3-scale": "/vendor/d3-scale/src/index.js",
            "./band.js": "/vendor/d3-scale/src/band.js",
            "./colors.js": "/vendor/d3-scale/src/colors.js",
            "./constant.js": "/vendor/d3-scale/src/constant.js",
            "./continuous.js": "/vendor/d3-scale/src/continuous.js",
            "./diverging.js": "/vendor/d3-scale/src/diverging.js",
            "./identity.js": "/vendor/d3-scale/src/identity.js",
            "./init.js": "/vendor/d3-scale/src/init.js",
            "./linear.js": "/vendor/d3-scale/src/linear.js",
            "./log.js": "/vendor/d3-scale/src/log.js",
            "./nice.js": "/vendor/d3-scale/src/nice.js",
            "./number.js": "/vendor/d3-scale/src/number.js",
            "./ordinal.js": "/vendor/d3-scale/src/ordinal.js",
            "./pow.js": "/vendor/d3-scale/src/pow.js",
            "./quantile.js": "/vendor/d3-scale/src/quantile.js",
            "./quantize.js": "/vendor/d3-scale/src/quantize.js",
            "./radial.js": "/vendor/d3-scale/src/radial.js",
            "./sequential.js": "/vendor/d3-scale/src/sequential.js",
            "./sequentialQuantile.js": "/vendor/d3-scale/src/sequentialQuantile.js",
            "./symlog.js": "/vendor/d3-scale/src/symlog.js",
            "./threshold.js": "/vendor/d3-scale/src/threshold.js",
            "./tickFormat.js": "/vendor/d3-scale/src/tickFormat.js",
            "./time.js": "/vendor/d3-scale/src/time.js",
            "./utcTime.js": "/vendor/d3-scale/src/utcTime.js",
            "d3-time": "/vendor/d3-time/src/index.js",
            "./interval.js": "/vendor/d3-time/src/interval.js",
            "./millisecond.js": "/vendor/d3-time/src/millisecond.js",
            "./second.js": "/vendor/d3-time/src/second.js",
            "./minute.js": "/vendor/d3-time/src/minute.js",
            "./hour.js": "/vendor/d3-time/src/hour.js",
            "./day.js": "/vendor/d3-time/src/day.js",
            "./week.js": "/vendor/d3-time/src/week.js",
            "./month.js": "/vendor/d3-time/src/month.js",
            "./year.js": "/vendor/d3-time/src/year.js",
            "./ticks.js": "/vendor/d3-time/src/ticks.js",
            "./duration.js": "/vendor/d3-time/src/duration.js",
            "d3-time-format": "/vendor/d3-time-format/src/index.js",
            "./defaultLocale.js": "/vendor/d3-time-format/src/defaultLocale.js",
            "./locale.js": "/vendor/d3-time-format/src/locale.js",
            "./isoFormat.js": "/vendor/d3-time-format/src/isoFormat.js",
            "./isoParse.js": "/vendor/d3-time-format/src/isoParse.js",
            "d3-drag": "/vendor/d3-drag/src/index.js",
            "./drag.js": "/vendor/d3-drag/src/drag.js",
            "./nodrag.js": "/vendor/d3-drag/src/nodrag.js",
            "./noevent.js": "/vendor/d3-drag/src/noevent.js",
            "./event.js": "/vendor/d3-drag/src/event.js",
            "./constant.js": "/vendor/d3-drag/src/constant.js",
            "internmap": "/vendor/internmap/src/index.js",
            "escape-string-regexp": "/vendor/escape-string-regexp/index.js",
            "crossfilter2": "/vendor/crossfilter2-es-wrapper.js",
            "@supabase/supabase-js": "data:text/javascript,export function createClient() { return { from: () => ({ insert: async () => ({ error: null }) }) }; }",
            "./watermark.js": "/vendor/modules/cosmograph/watermark.js",
            "./config.js": "/vendor/modules/cosmograph/config.js",
            "./style.module.css.js": "/vendor/modules/cosmograph/style.module.css.js",
            "./crossfilter.js": "/vendor/modules/cosmograph/crossfilter.js",
            "../../api/supabase/supabase.js": "/vendor/api/supabase/supabase.js",
            "./../../ext/rollup-plugin-styles/dist/runtime/inject-css.js": "data:text/javascript,export default function() {}"
        }
    }
    </script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #0a0a0a;
            color: #fff;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #cosmograph-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(20, 20, 20, 0.95);
            padding: 20px;
            border-radius: 8px;
            max-width: 350px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .stats-card {
            background-color: rgba(40, 40, 40, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        .btn-primary {
            background-color: #4ecdc4;
            border-color: #4ecdc4;
        }
        .btn-primary:hover {
            background-color: #3eb8b0;
            border-color: #3eb8b0;
        }
        .btn-danger {
            background-color: #ff6b6b;
            border-color: #ff6b6b;
        }
        .gpu-badge {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 10px;
            display: inline-block;
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            visibility: hidden;
        }
        .loading-overlay.active {
            visibility: visible;
        }
        .loading-content {
            text-align: center;
        }
        .performance-metrics {
            font-family: monospace;
            font-size: 0.9em;
            color: #4ecdc4;
        }
        #fps-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(20, 20, 20, 0.9);
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
            z-index: 1000;
        }
        .toggle-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(20, 20, 20, 0.9);
            padding: 10px;
            border-radius: 4px;
            z-index: 1000;
        }
        /* Scrollbar styling */
        .control-panel::-webkit-scrollbar {
            width: 8px;
        }
        .control-panel::-webkit-scrollbar-track {
            background: rgba(40, 40, 40, 0.5);
            border-radius: 4px;
        }
        .control-panel::-webkit-scrollbar-thumb {
            background: #4ecdc4;
            border-radius: 4px;
        }
        
        /* Node details panel */
        .node-details-panel {
            position: fixed;  /* Changed from absolute to fixed */
            top: 20px;
            right: 20px;
            background-color: rgba(20, 20, 20, 0.98);  /* Slightly more opaque */
            padding: 20px;
            border-radius: 8px;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 10000;  /* Much higher z-index */
            box-shadow: 0 4px 20px rgba(0,0,0,0.8);
            display: none;
            animation: slideIn 0.3s ease-out;
            border: 1px solid #4ecdc4;  /* Add border for visibility */
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .node-details-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        
        .node-details-header h5 {
            margin: 0;
            color: #4ecdc4;
        }
        
        .btn-close {
            background: none;
            border: none;
            color: #999;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn-close:hover {
            color: #fff;
        }
        
        .node-details-content {
            font-size: 14px;
            line-height: 1.6;
        }
        
        .node-details-content > div {
            margin-bottom: 8px;
            word-break: break-word;
        }
        
        .node-details-content strong {
            color: #4ecdc4;
            margin-right: 5px;
        }
        
        .summary-section {
            background: rgba(40, 40, 40, 0.5);
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .centrality-section {
            margin-top: 15px;
        }
        
        .json-section {
            margin-top: 15px;
        }
        
        /* Progress bar styling */
        .progress {
            background-color: rgba(40, 40, 40, 0.8);
        }
        
        .progress-bar {
            transition: width 0.3s ease;
        }
        
        /* Filter panel */
        .filter-panel {
            position: absolute;
            bottom: 100px;
            left: 20px;
            background-color: rgba(20, 20, 20, 0.95);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            z-index: 1000;
            display: none;
        }
        
        .filter-panel.active {
            display: block;
        }
        
        /* Search results styling */
        #search-results {
            background-color: rgba(30, 30, 30, 0.95);
            border: 1px solid #4ecdc4;
            border-radius: 4px;
        }
        
        .search-result-item:hover {
            background-color: rgba(78, 205, 196, 0.2);
        }
        
        /* Tab styling for filters */
        .nav-tabs-sm .nav-link {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
        }
        
        /* Enhanced graph animation */
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <script>
        console.log('Page loaded - basic script tag works');
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded from basic script');
        });
    </script>
    <div id="cosmograph-container"></div>
    
    <div id="fps-counter">
        <div>FPS: <span id="fps">0</span></div>
        <div>Nodes: <span id="rendered-nodes">0</span></div>
        <div>Edges: <span id="rendered-edges">0</span></div>
    </div>
    
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-content">
            <div class="spinner-border text-primary" style="width: 3rem; height: 3rem;" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <h3 class="mt-3">Loading Graph Data...</h3>
            <p class="performance-metrics" id="loading-status">Fetching data from FalkorDB</p>
        </div>
    </div>
    
    <div class="control-panel">
        <h4>
            🚀 Cosmograph GPU Visualizer
            <span class="gpu-badge">WebGL</span>
        </h4>
        
        <div class="stats-card">
            <h5>📊 Graph Statistics</h5>
            <div><strong>Total Nodes:</strong> <span id="total-nodes">-</span></div>
            <div><strong>Total Edges:</strong> <span id="total-edges">-</span></div>
            <div><strong>Query Time:</strong> <span id="query-time">-</span> ms</div>
            <div class="mt-2 performance-metrics">
                <div>GPU Memory: <span id="gpu-memory">-</span></div>
                <div>Render Time: <span id="render-time">-</span> ms</div>
            </div>
        </div>
        
        <div class="card-header mt-3">
            <h6 class="mb-0">🔍 Search & Navigation</h6>
        </div>
        <div class="card-body">
            <div class="mb-3">
                <div class="input-group input-group-sm">
                    <input type="text" class="form-control" id="node-search" placeholder="Search nodes by name or property...">
                    <button class="btn btn-outline-secondary" type="button" id="clear-search">✕</button>
                </div>
                <div id="search-results" class="mt-2 small" style="max-height: 150px; overflow-y: auto; display: none;">
                </div>
            </div>
            
            <div class="mb-2">
                <button id="find-path" class="btn btn-sm btn-outline-primary w-100" title="Find shortest path between two selected nodes">
                    📍 Find Path Between Nodes
                </button>
            </div>
            
            <div class="mb-2">
                <button id="show-neighbors" class="btn btn-sm btn-outline-info w-100" title="Show all neighbors of selected nodes">
                    🔗 Show Neighbors
                </button>
            </div>
            
            <div class="mb-2">
                <button id="focus-subgraph" class="btn btn-sm btn-outline-warning w-100" title="Focus view on selected nodes and their connections">
                    🎯 Focus on Selection
                </button>
            </div>
        </div>
        
        <div class="mb-3">
            <h5>🎮 Visualization Controls</h5>
            
            <div class="mb-2">
                <label for="query-type" class="form-label">Query Type:</label>
                <select id="query-type" class="form-select form-select-sm">
                    <option value="entire_graph">Entire Graph (GPU)</option>
                    <option value="high_degree">High Degree Nodes</option>
                    <option value="agents">Agent Networks</option>
                </select>
            </div>
            
            <div class="mb-2">
                <label for="node-limit" class="form-label">Node Limit:</label>
                <input type="number" id="node-limit" class="form-control form-control-sm" value="50000" min="100" max="100000">
                <small class="text-muted">Full graph: ~4.5k nodes, 14k edges</small>
            </div>
            
            <button id="visualize-btn" class="btn btn-primary w-100 mb-2">Visualize</button>
            <button id="load-entire-graph-btn" class="btn btn-danger w-100 mb-3">
                ⚡ Load Entire Graph (GPU)
            </button>
        </div>
        
        <div class="stats-card">
            <h5>⚙️ Rendering Settings</h5>
            <div class="mb-2">
                <label for="node-size" class="form-label">Node Size: <span id="node-size-value">5</span></label>
                <input type="range" class="form-range" id="node-size" min="1" max="20" step="1" value="5">
            </div>
            
            <div class="mb-2">
                <label for="link-width" class="form-label">Link Width: <span id="link-width-value">0.5</span></label>
                <input type="range" class="form-range" id="link-width" min="0.1" max="5" step="0.1" value="0.5">
            </div>
            
            <div class="mb-2">
                <label for="link-opacity" class="form-label">Link Opacity: <span id="link-opacity-value">0.5</span></label>
                <input type="range" class="form-range" id="link-opacity" min="0" max="1" step="0.1" value="0.5">
            </div>
            
            <div class="mb-2">
                <label for="simulation-decay" class="form-label">Simulation Decay: <span id="simulation-decay-value">3000</span></label>
                <input type="range" class="form-range" id="simulation-decay" min="100" max="10000" step="100" value="3000">
            </div>
            
            <div class="mb-2">
                <label for="repulsion" class="form-label">Repulsion Force: <span id="repulsion-value">1.0</span></label>
                <input type="range" class="form-range" id="repulsion" min="0" max="2" step="0.1" value="1.0">
            </div>
            
            <div class="mb-2">
                <label for="gravity" class="form-label">Center Gravity: <span id="gravity-value">0.1</span></label>
                <input type="range" class="form-range" id="gravity" min="0" max="1" step="0.05" value="0.1">
            </div>
            
            <div class="mb-2">
                <label for="center-force" class="form-label">Center Force: <span id="center-force-value">0.2</span></label>
                <input type="range" class="form-range" id="center-force" min="0" max="0.5" step="0.05" value="0.2">
            </div>
            
            <div class="mb-2">
                <label for="friction" class="form-label">Friction/Drag: <span id="friction-value">0.85</span></label>
                <input type="range" class="form-range" id="friction" min="0.5" max="0.99" step="0.01" value="0.85">
            </div>
            
            
            <div class="mb-2">
                <label for="link-spring" class="form-label">Link Spring: <span id="link-spring-value">0.5</span></label>
                <input type="range" class="form-range" id="link-spring" min="0" max="2" step="0.1" value="0.5">
            </div>
            
            <div class="mb-2">
                <label for="link-distance" class="form-label">Link Distance: <span id="link-distance-value">20</span></label>
                <input type="range" class="form-range" id="link-distance" min="5" max="100" step="5" value="20">
            </div>
            
            <div class="mb-2">
                <label for="mouse-repulsion" class="form-label">Mouse Repulsion: <span id="mouse-repulsion-value">2</span></label>
                <input type="range" class="form-range" id="mouse-repulsion" min="0" max="40" step="1" value="2">
            </div>
        </div>
        
        <div class="stats-card">
            <h5>🌀 Advanced Physics</h5>
            <div class="mb-2">
                <button id="toggle-custom-physics" class="btn btn-sm btn-success w-100">Enable Custom Physics</button>
            </div>
            <div class="mb-2">
                <button id="apply-explosion" class="btn btn-sm btn-warning w-100">Explosion Effect</button>
            </div>
            <div class="mb-2">
                <button id="randomize-positions" class="btn btn-sm btn-secondary w-100">Randomize Positions</button>
            </div>
            <div class="mb-2">
                <button id="reset-physics" class="btn btn-sm btn-danger w-100">Reset Physics</button>
            </div>
        </div>
        
        <div class="card-header mt-3">
            <h6 class="mb-0">Node Size Controls</h6>
        </div>
        <div class="card-body">
            <div class="mb-2">
                <label for="node-min-size" class="form-label">Min Node Size: <span id="node-min-size-value">2</span>px</label>
                <input type="range" class="form-range" id="node-min-size" min="1" max="10" step="0.5" value="2">
            </div>
            
            <div class="mb-2">
                <label for="node-max-size" class="form-label">Max Node Size: <span id="node-max-size-value">6</span>px</label>
                <input type="range" class="form-range" id="node-max-size" min="3" max="20" step="0.5" value="6">
            </div>
            
            <div class="mb-2">
                <label for="node-size-scale" class="form-label">Overall Scale: <span id="node-size-scale-value">1.0</span>x</label>
                <input type="range" class="form-range" id="node-size-scale" min="0.5" max="3" step="0.1" value="1">
            </div>
            
            <small class="text-muted d-block mt-2">
                <strong>Controls:</strong><br>
                • Left click: Select node<br>
                • Shift + click: Multi-select nodes<br>
                • Left click + drag node: Move node<br>
                • Middle click + drag: Pan view<br>
                • Scroll: Zoom in/out
            </small>
        </div>
        
        <div class="card-header mt-3">
            <h6 class="mb-0">⚡ Quick Actions</h6>
        </div>
        <div class="card-body">
            <div class="mb-2">
                <button id="pin-selected" class="btn btn-sm btn-outline-secondary w-100" title="Pin selected nodes in place">
                    📌 Pin Selected
                </button>
            </div>
            
            <div class="mb-2">
                <button id="unpin-all" class="btn btn-sm btn-outline-secondary w-100" title="Unpin all nodes">
                    🔓 Unpin All
                </button>
            </div>
            
            <div class="mb-2">
                <button id="hide-selected" class="btn btn-sm btn-outline-warning w-100" title="Hide selected nodes">
                    👁️‍🗨️ Hide Selected
                </button>
            </div>
            
            <div class="mb-2">
                <button id="show-all" class="btn btn-sm btn-outline-info w-100" title="Show all hidden nodes">
                    👁️ Show All Hidden
                </button>
            </div>
            
            <div class="mb-2">
                <button id="export-selection" class="btn btn-sm btn-outline-success w-100" title="Export selected subgraph">
                    💾 Export Selection
                </button>
            </div>
            
            <div class="mb-2">
                <small class="text-muted">
                    <span id="selected-count">0</span> nodes selected
                </small>
            </div>
        </div>
        
        <div class="card-header mt-3">
            <h6 class="mb-0">🔀 Graph Layouts</h6>
        </div>
        <div class="card-body">
            <div class="mb-3">
                <label for="layout-type" class="form-label">Layout Type</label>
                <select class="form-select form-select-sm" id="layout-type">
                    <option value="force" selected>Force-Directed</option>
                    <option value="hierarchical">Hierarchical</option>
                    <option value="radial">Radial</option>
                    <option value="circular">Circular</option>
                    <option value="temporal">Temporal</option>
                    <option value="cluster">Cluster</option>
                </select>
            </div>
            
            <div id="layout-options" class="mb-3">
                <!-- Dynamic options based on layout type -->
            </div>
            
            <button id="apply-layout" class="btn btn-sm btn-primary w-100">Apply Layout</button>
        </div>
        
        <div class="card-header mt-3">
            <h6 class="mb-0">Styling Options</h6>
        </div>
        <div class="card-body">
            <div class="mb-3">
                <label for="node-color-scheme" class="form-label">Node Color Scheme</label>
                <select class="form-select form-select-sm" id="node-color-scheme">
                    <option value="type" selected>By Type</option>
                    <option value="centrality">By Centrality</option>
                    <option value="degree">By Degree</option>
                    <option value="pagerank">By PageRank</option>
                    <option value="custom">Custom</option>
                </select>
            </div>
            
            <div class="mb-3">
                <label for="link-color" class="form-label">Link Color</label>
                <input type="color" class="form-control form-control-sm" id="link-color" value="#666666">
            </div>
            
            <div class="mb-3">
                <label for="background-color" class="form-label">Background Color</label>
                <input type="color" class="form-control form-control-sm" id="background-color" value="#0a0a0a">
            </div>
            
            <div class="mb-2">
                <label for="label-size" class="form-label">Label Size: <span id="label-size-value">12</span>px</label>
                <input type="range" class="form-range" id="label-size" min="8" max="24" step="1" value="12">
            </div>
        </div>
        
        <div class="stats-card">
            <h5>🐛 Debug Tools</h5>
            <div class="mb-2">
                <button id="test-node-details" class="btn btn-sm btn-info w-100">Test Node Details Panel</button>
            </div>
        </div>
        
        <div class="mt-3">
            <h6>Controls:</h6>
            <ul class="small">
                <li>🖱️ Scroll/Pinch to zoom</li>
                <li>👆 Click & drag to pan</li>
                <li>🎯 Click nodes for details</li>
                <li>⌨️ Space to pause/resume</li>
                <li>🔍 Hover nodes to see labels</li>
                <li>⚡ Right-click for mouse repulsion</li>
            </ul>
        </div>
    </div>
    
    <div class="toggle-controls">
        <button id="toggle-panel" class="btn btn-sm btn-secondary">Toggle Panel</button>
        <button id="pause-simulation" class="btn btn-sm btn-warning">Pause</button>
        <button id="fit-view" class="btn btn-sm btn-info">Fit View</button>
        <button id="toggle-filters" class="btn btn-sm btn-primary">Filters</button>
    </div>
    
    <div class="filter-panel" id="filter-panel">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h5 class="mb-0">🔍 Advanced Filters</h5>
            <button class="btn btn-sm btn-outline-secondary" id="close-filters">✕</button>
        </div>
        
        <ul class="nav nav-tabs nav-tabs-sm mb-3" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#filter-basic" type="button">Basic</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#filter-metrics" type="button">Metrics</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#filter-time" type="button">Time</button>
            </li>
        </ul>
        
        <div class="tab-content">
            <div class="tab-pane fade show active" id="filter-basic" role="tabpanel">
                <div class="mb-3">
                    <label class="form-label">Node Type</label>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="filter-entity" checked>
                        <label class="form-check-label" for="filter-entity">Entity</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="filter-episodic" checked>
                        <label class="form-check-label" for="filter-episodic">Episodic</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="filter-agent" checked>
                        <label class="form-check-label" for="filter-agent">Agent</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="filter-community" checked>
                        <label class="form-check-label" for="filter-community">Community</label>
                    </div>
                </div>
            </div>
            
            <div class="tab-pane fade" id="filter-metrics" role="tabpanel">
                <div class="mb-3">
                    <label for="centrality-threshold" class="form-label">
                        Min Centrality: <span id="centrality-value">0</span>
                    </label>
                    <input type="range" class="form-range" id="centrality-threshold" 
                           min="0" max="50" step="1" value="0">
                </div>
                
                <div class="mb-3">
                    <label for="degree-range" class="form-label">Degree Range</label>
                    <div class="d-flex gap-2">
                        <input type="number" class="form-control form-control-sm" id="min-degree" placeholder="Min" value="0" min="0">
                        <input type="number" class="form-control form-control-sm" id="max-degree" placeholder="Max" min="0">
                    </div>
                </div>
                
                <div class="mb-3">
                    <label for="pagerank-threshold" class="form-label">
                        Min PageRank: <span id="pagerank-value">0</span>
                    </label>
                    <input type="range" class="form-range" id="pagerank-threshold" 
                           min="0" max="100" step="1" value="0">
                </div>
            </div>
            
            <div class="tab-pane fade" id="filter-time" role="tabpanel">
                <div class="mb-3">
                    <label class="form-label">Created After</label>
                    <input type="datetime-local" class="form-control form-control-sm" id="created-after">
                </div>
                
                <div class="mb-3">
                    <label class="form-label">Created Before</label>
                    <input type="datetime-local" class="form-control form-control-sm" id="created-before">
                </div>
                
                <div class="mb-3">
                    <label class="form-label">Quick Presets</label>
                    <div class="btn-group btn-group-sm w-100" role="group">
                        <button type="button" class="btn btn-outline-secondary time-preset" data-days="1">24h</button>
                        <button type="button" class="btn btn-outline-secondary time-preset" data-days="7">7d</button>
                        <button type="button" class="btn btn-outline-secondary time-preset" data-days="30">30d</button>
                        <button type="button" class="btn btn-outline-secondary time-preset" data-days="365">1y</button>
                    </div>
                </div>
            </div>
        </div>
        
        <button id="apply-filters" class="btn btn-sm btn-primary w-100">Apply Filters</button>
        <button id="reset-filters" class="btn btn-sm btn-secondary w-100 mt-2">Reset</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Debug script for testing -->
    <script src="/debug-cosmograph.js"></script>
    <script type="module">
        console.log('Module script started');
        import { Cosmograph } from '@cosmograph/cosmograph';
        console.log('Cosmograph imported successfully:', Cosmograph);
        
        let cosmograph = null;
        let currentData = null;
        let nodeDataMap = new Map(); // Store original node data by ID
        let isPaused = false;
        let frameCount = 0;
        let lastTime = performance.now();
        
        // Base configuration to maintain label settings
        const baseConfig = {
            showDynamicLabels: false,  // Never show random labels
            showHoveredNodeLabel: true,  // Only show labels on hover
            nodeLabelAccessor: node => node.label || node.properties?.name || node.id  // Use label field, not ID
        };
        let customPhysicsEnabled = false;
        let centerGravity = 0.1;
        let dragCoefficient = 0.02;
        let spiralForce = 0.05;
        let tangentialDrag = 0.01;
        let nodeVelocities = new Map();
        let nodePositions = new Map();
        let animationFrame = null;
        
        // Initialize - check if DOM is already loaded
        function initialize() {
            console.log('Initialize function called');
            try {
                initializeCosmograph();
                console.log('initializeCosmograph completed');
            } catch (error) {
                console.error('Error in initializeCosmograph:', error);
            }
            
            try {
                loadStats();
                console.log('loadStats completed');
            } catch (error) {
                console.error('Error in loadStats:', error);
            }
            
            try {
                setupEventListeners();
                console.log('setupEventListeners completed');
            } catch (error) {
                console.error('Error in setupEventListeners:', error);
            }
            
            updateFPS();
            
            // Load initial visualization
            setTimeout(() => {
                console.log('Calling initial visualization...');
                window.visualize();
            }, 500);
        }
        
        // Check if DOM is already loaded
        if (document.readyState === 'loading') {
            console.log('DOM still loading, adding event listener');
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            console.log('DOM already loaded, initializing immediately');
            initialize();
        }
        
        function initializeCosmograph() {
            console.log('initializeCosmograph called');
            const container = document.getElementById('cosmograph-container');
            console.log('Container:', container, 'Width:', container?.offsetWidth, 'Height:', container?.offsetHeight);
            
            const config = {
                ...baseConfig,  // Include base label configuration
                backgroundColor: '#0a0a0a',
                nodeColor: node => {
                    // Color based on node type with intensity based on importance
                    const baseColors = {
                        'Entity': [255, 107, 107],  // #ff6b6b
                        'Episodic': [78, 205, 196], // #4ecdc4
                        'Agent': [255, 230, 109]     // #ffe66d
                    };
                    const [r, g, b] = baseColors[node.node_type] || [149, 225, 211]; // #95e1d3
                    
                    // Use importance_centrality or pagerank to adjust brightness
                    const importance = node.properties?.importance_centrality || node.properties?.pagerank_centrality || 0.5;
                    const brightness = 0.5 + (importance * 0.5); // Range 0.5 to 1.0
                    
                    const finalR = Math.round(r * brightness);
                    const finalG = Math.round(g * brightness);
                    const finalB = Math.round(b * brightness);
                    
                    return `rgb(${finalR}, ${finalG}, ${finalB})`;
                },
                nodeSize: node => {
                    // Dynamic size based on centrality scores
                    const props = node.properties || {};
                    const degree = props.degree_centrality || 0;
                    const pagerank = props.pagerank_centrality || 0;
                    
                    // Combine metrics for size (weighted average)
                    const combinedScore = (degree * 0.7 + pagerank * 0.3);
                    
                    // Get min and max size from UI controls (will be set later)
                    const minSize = parseFloat(document.getElementById('node-min-size')?.value || 2);
                    const maxSize = parseFloat(document.getElementById('node-max-size')?.value || 6);
                    
                    // Use logarithmic scaling to compress the range
                    const logScore = Math.log(1 + combinedScore * 10);
                    const normalizedScore = Math.min(logScore / Math.log(11), 1); // Normalize to 0-1
                    
                    // Scale between min and max
                    return minSize + (normalizedScore * (maxSize - minSize));
                },
                nodeLabel: node => {
                    // Show labels for high-centrality nodes
                    const props = node.properties || {};
                    const degree = props.degree_centrality || 0;
                    if (degree > 10 || node.node_type === 'Agent') {
                        return node.label || props.name || '';
                    }
                    return '';
                },
                linkColor: '#666666',
                linkWidth: 0.5,
                linkArrows: true,
                linkArrowsSizeScale: 0.5,
                simulationGravity: 0.1,  // Default gravity to keep nodes together
                simulationCenter: 0.2,  // Stronger center force by default
                simulationRepulsion: 1.0,
                simulationLinkDistance: 20,
                simulationLinkSpring: 0.5,
                simulationDecay: 3000,
                simulationFriction: 0.85,
                renderLinks: true,
                renderHoveredNodeRing: true,
                hoveredNodeRingColor: '#4ecdc4',
                focusedNodeRingColor: '#ff6b6b',
                disableGreyoutNonHoveredOnHover: false,
                greyoutNonHighlightedNodes: false,
                // Add onClick at root level as per Cosmograph docs
                onClick: (node, index, position, event) => {
                    console.log('onClick event fired - node:', node, 'index:', index, 'position:', position, 'shiftKey:', event?.shiftKey);
                    if (node) {
                        console.log('Clicked node data:', node);
                        console.log('Node ID:', node.id);
                        
                        // Handle multi-select with shift key
                        if (event?.shiftKey) {
                            // Get currently selected nodes
                            const currentlySelected = cosmograph.getSelectedNodes() || [];
                            const isAlreadySelected = currentlySelected.some(n => n.id === node.id);
                            
                            if (isAlreadySelected) {
                                // Deselect this node
                                const newSelection = currentlySelected.filter(n => n.id !== node.id);
                                cosmograph.selectNodes(newSelection);
                                console.log('Deselected node, total selected:', newSelection.length);
                            } else {
                                // Add to selection
                                const newSelection = [...currentlySelected, node];
                                cosmograph.selectNodes(newSelection);
                                console.log('Added to selection, total selected:', newSelection.length);
                            }
                        } else {
                            // Normal click - select only this node
                            cosmograph.selectNodes([node]);
                        }
                        
                        // Update selection counter
                        updateSelectionCounter();
                        
                        // Show details for the clicked node
                        const originalNode = nodeDataMap.get(node.id);
                        if (originalNode) {
                            console.log('Found original node data:', originalNode);
                            window.showNodeDetails(originalNode);
                        } else {
                            console.log('Original node data not found, using clicked node');
                            window.showNodeDetails(node);
                        }
                    } else {
                        console.log('Clicked on empty space');
                    }
                },
                onNodeMouseOver: (node) => {
                    if (node && node.properties?.summary) {
                        // Could show tooltip with summary
                        console.log('Hover node:', node.label, 'Summary:', node.properties.summary);
                    }
                }
            };
            
            console.log('Creating Cosmograph with config:', config);
            try {
                cosmograph = new Cosmograph(container, config);
                console.log('Cosmograph created successfully:', cosmograph);
                
                // Add a test click listener to the container
                container.addEventListener('click', (e) => {
                    console.log('Container clicked at:', e.clientX, e.clientY);
                });
                
                // Try to access the canvas element directly
                setTimeout(() => {
                    const canvas = container.querySelector('canvas');
                    if (canvas) {
                        console.log('Found canvas element:', canvas);
                        // Add middle mouse button handling for panning
                        let isPanning = false;
                        let panStartX = 0;
                        let panStartY = 0;
                        
                        canvas.addEventListener('mousedown', (e) => {
                            if (e.button === 1) { // Middle mouse button
                                e.preventDefault();
                                isPanning = true;
                                panStartX = e.clientX;
                                panStartY = e.clientY;
                                canvas.style.cursor = 'grabbing';
                                console.log('Middle mouse pan started');
                            }
                        });
                        
                        canvas.addEventListener('mousemove', (e) => {
                            if (isPanning) {
                                const dx = e.clientX - panStartX;
                                const dy = e.clientY - panStartY;
                                
                                // Get current transform and apply pan
                                if (cosmograph) {
                                    const currentTransform = cosmograph.getZoomLevel();
                                    // Note: This is a simplified approach - Cosmograph may need specific pan API
                                    console.log('Panning by:', dx, dy);
                                }
                                
                                panStartX = e.clientX;
                                panStartY = e.clientY;
                            }
                        });
                        
                        canvas.addEventListener('mouseup', (e) => {
                            if (e.button === 1 && isPanning) {
                                isPanning = false;
                                canvas.style.cursor = 'default';
                                console.log('Middle mouse pan ended');
                            }
                        });
                        
                        // Prevent context menu on middle click
                        canvas.addEventListener('contextmenu', (e) => {
                            if (e.button === 1) {
                                e.preventDefault();
                            }
                        });
                        
                        canvas.addEventListener('click', (e) => {
                            console.log('Canvas clicked at:', e.clientX, e.clientY);
                            
                            // If onClick isn't working, try using selection API
                            const rect = canvas.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const y = e.clientY - rect.top;
                            
                            // Check if we have any selected nodes after a small delay
                            setTimeout(() => {
                                const selectedNodes = cosmograph.getSelectedNodes();
                                if (!selectedNodes || selectedNodes.length === 0) {
                                    // No nodes selected, this is a click on empty space
                                    console.log('Click on empty space - resetting selection');
                                    // Explicitly deselect and refresh
                                    cosmograph.selectNodes([]); // Deselect all
                                    cosmograph.unselectNodes(); // Force unselection
                                    
                                    // Hide the details panel
                                    const detailsPanel = document.getElementById('node-details-panel');
                                    if (detailsPanel) {
                                        detailsPanel.style.display = 'none';
                                    }
                                    
                                    // Force a render update to ensure all nodes are visible
                                    cosmograph.setConfig({ ...baseConfig });
                                    
                                    // Update selection counter
                                    updateSelectionCounter();
                                }
                            }, 50); // Small delay to let onClick handler process first
                            
                            // Try to select nodes in a small area around the click
                            const selectionSize = 20; // pixels
                            try {
                                // Convert to graph coordinates if needed
                                const selection = [
                                    [x - selectionSize/2, y - selectionSize/2],
                                    [x + selectionSize/2, y + selectionSize/2]
                                ];
                                
                                console.log('Attempting to select nodes in range:', selection);
                                cosmograph.selectNodesInRange(selection);
                                
                                // Check if any nodes were selected
                                setTimeout(() => {
                                    const selectedNodes = cosmograph.getSelectedNodes();
                                    console.log('Selected nodes after range selection:', selectedNodes);
                                    
                                    if (selectedNodes && selectedNodes.length > 0) {
                                        const node = selectedNodes[0];
                                        const originalNode = nodeDataMap.get(node.id);
                                        if (originalNode) {
                                            console.log('Showing details for selected node:', originalNode);
                                            window.showNodeDetails(originalNode);
                                        } else {
                                            window.showNodeDetails(node);
                                        }
                                    }
                                }, 100);
                            } catch (err) {
                                console.error('Error selecting nodes:', err);
                            }
                        });
                    } else {
                        console.log('Canvas element not found');
                    }
                    
                    // Log available cosmograph methods
                    console.log('Cosmograph methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(cosmograph)));
                    
                }, 1000);
                
            } catch (error) {
                console.error('Error creating Cosmograph:', error);
                throw error;
            }
        }
        
        function setupEventListeners() {
            console.log('setupEventListeners called');
            document.getElementById('visualize-btn').addEventListener('click', window.visualize);
            document.getElementById('load-entire-graph-btn').addEventListener('click', window.loadEntireGraph);
            document.getElementById('toggle-panel').addEventListener('click', window.togglePanel);
            document.getElementById('pause-simulation').addEventListener('click', window.toggleSimulation);
            document.getElementById('fit-view').addEventListener('click', () => {
                if (cosmograph) {
                    cosmograph.fitView();
                }
            });
            
            // Query type change listener
            document.getElementById('query-type').addEventListener('change', (e) => {
                console.log('Query type changed to:', e.target.value);
            });
            
            // Settings listeners
            document.getElementById('node-size').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('node-size-value').textContent = value;
                if (cosmograph) {
                    console.log('Setting node size to:', value);
                    cosmograph.setConfig({ ...baseConfig, nodeSize: value });
                }
            });
            
            document.getElementById('link-width').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('link-width-value').textContent = value;
                if (cosmograph) {
                    console.log('Setting link width to:', value);
                    cosmograph.setConfig({ ...baseConfig, linkWidth: value });
                }
            });
            
            document.getElementById('link-opacity').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('link-opacity-value').textContent = value;
                if (cosmograph) {
                    // Opacity is handled via linkColor alpha
                    const opacity = Math.round(value * 255).toString(16).padStart(2, '0');
                    console.log('Setting link opacity to:', value, 'color:', `#666666${opacity}`);
                    cosmograph.setConfig({ ...baseConfig, linkColor: `#666666${opacity}` });
                }
            });
            
            document.getElementById('simulation-decay').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('simulation-decay-value').textContent = value;
                if (cosmograph) {
                    console.log('Setting simulation decay to:', value);
                    cosmograph.setConfig({ ...baseConfig, simulationDecay: value });
                }
            });
            
            document.getElementById('repulsion').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('repulsion-value').textContent = value;
                if (cosmograph) {
                    console.log('Setting repulsion to:', value);
                    cosmograph.setConfig({ ...baseConfig, simulationRepulsion: value });
                }
            });
            
            document.getElementById('center-force').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('center-force-value').textContent = value;
                if (cosmograph) {
                    console.log('Setting center force to:', value);
                    cosmograph.setConfig({ ...baseConfig, simulationCenter: value });
                }
            });
            
            document.getElementById('gravity').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('gravity-value').textContent = value;
                if (cosmograph) {
                    console.log('Setting gravity to:', value);
                    cosmograph.setConfig({ ...baseConfig, simulationGravity: value });
                }
            });
            
            document.getElementById('friction').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('friction-value').textContent = value;
                if (cosmograph) {
                    console.log('Setting friction to:', value);
                    cosmograph.setConfig({ ...baseConfig, simulationFriction: value });
                }
            });
            
            document.getElementById('link-spring').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('link-spring-value').textContent = value;
                if (cosmograph) {
                    console.log('Setting link spring to:', value);
                    cosmograph.setConfig({ ...baseConfig, simulationLinkSpring: value });
                }
            });
            
            document.getElementById('link-distance').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('link-distance-value').textContent = value;
                if (cosmograph) {
                    console.log('Setting link distance to:', value);
                    cosmograph.setConfig({ ...baseConfig, simulationLinkDistance: value });
                }
            });
            
            document.getElementById('mouse-repulsion').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('mouse-repulsion-value').textContent = value;
                if (cosmograph) {
                    console.log('Setting mouse repulsion to:', value);
                    cosmograph.setConfig({ ...baseConfig, simulationRepulsionFromMouse: value });
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    window.toggleSimulation();
                }
            });
            
            // Filter panel controls
            document.getElementById('toggle-filters').addEventListener('click', () => {
                const panel = document.getElementById('filter-panel');
                panel.classList.toggle('active');
            });
            
            document.getElementById('centrality-threshold').addEventListener('input', (e) => {
                document.getElementById('centrality-value').textContent = e.target.value;
            });
            
            document.getElementById('apply-filters').addEventListener('click', applyFilters);
            document.getElementById('reset-filters').addEventListener('click', resetFilters);
            
            // Advanced physics controls
            document.getElementById('toggle-custom-physics').addEventListener('click', toggleCustomPhysics);
            document.getElementById('apply-explosion').addEventListener('click', applyExplosion);
            document.getElementById('randomize-positions').addEventListener('click', randomizePositions);
            document.getElementById('reset-physics').addEventListener('click', resetPhysics);
            
            // Node size controls
            document.getElementById('node-min-size').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('node-min-size-value').textContent = value;
                if (cosmograph && currentData) {
                    console.log('Setting min node size to:', value);
                    // Re-render with new size range
                    processAndRenderGraph(currentData);
                }
            });
            
            document.getElementById('node-max-size').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('node-max-size-value').textContent = value;
                if (cosmograph && currentData) {
                    console.log('Setting max node size to:', value);
                    // Re-render with new size range
                    processAndRenderGraph(currentData);
                }
            });
            
            // Node size scale slider
            document.getElementById('node-size-scale').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('node-size-scale-value').textContent = value.toFixed(1);
                if (cosmograph) {
                    console.log('Setting node size scale to:', value);
                    cosmograph.setConfig({ ...baseConfig, nodeSizeScale: value });
                }
            });
            
            // Styling options
            document.getElementById('node-color-scheme').addEventListener('change', (e) => {
                const scheme = e.target.value;
                console.log('Changing node color scheme to:', scheme);
                if (cosmograph && currentData) {
                    updateNodeColors(scheme);
                }
            });
            
            document.getElementById('link-color').addEventListener('input', (e) => {
                const color = e.target.value;
                console.log('Setting link color to:', color);
                if (cosmograph) {
                    cosmograph.setConfig({ ...baseConfig, linkColor: color });
                }
            });
            
            document.getElementById('background-color').addEventListener('input', (e) => {
                const color = e.target.value;
                console.log('Setting background color to:', color);
                if (cosmograph) {
                    cosmograph.setConfig({ ...baseConfig, backgroundColor: color });
                }
            });
            
            document.getElementById('label-size').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('label-size-value').textContent = value;
                console.log('Setting label size to:', value);
                // Note: Cosmograph doesn't directly support label size, but we can update CSS
                const style = document.createElement('style');
                style.textContent = `.cosmograph-label { font-size: ${value}px !important; }`;
                document.head.appendChild(style);
            });
            
            // Search functionality
            let searchTimeout;
            document.getElementById('node-search').addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                const searchTerm = e.target.value.toLowerCase().trim();
                
                if (searchTerm.length < 2) {
                    document.getElementById('search-results').style.display = 'none';
                    return;
                }
                
                searchTimeout = setTimeout(() => {
                    searchNodes(searchTerm);
                }, 300); // Debounce search
            });
            
            document.getElementById('clear-search').addEventListener('click', () => {
                document.getElementById('node-search').value = '';
                document.getElementById('search-results').style.display = 'none';
                if (cosmograph) {
                    cosmograph.selectNodes([]); // Clear selection
                }
            });
            
            // Navigation controls
            document.getElementById('find-path').addEventListener('click', findPathBetweenNodes);
            document.getElementById('show-neighbors').addEventListener('click', showNeighbors);
            document.getElementById('focus-subgraph').addEventListener('click', focusOnSelection);
            
            // Advanced filter controls
            document.getElementById('close-filters').addEventListener('click', () => {
                document.getElementById('filter-panel').classList.remove('active');
            });
            
            document.getElementById('pagerank-threshold').addEventListener('input', (e) => {
                document.getElementById('pagerank-value').textContent = e.target.value;
            });
            
            // Time preset buttons
            document.querySelectorAll('.time-preset').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const days = parseInt(e.target.dataset.days);
                    const now = new Date();
                    const past = new Date(now - days * 24 * 60 * 60 * 1000);
                    document.getElementById('created-after').value = past.toISOString().slice(0, 16);
                    document.getElementById('created-before').value = now.toISOString().slice(0, 16);
                });
            });
            
            // Quick actions
            let pinnedNodes = new Set();
            let hiddenNodes = new Set();
            
            document.getElementById('pin-selected').addEventListener('click', () => {
                const selected = cosmograph?.getSelectedNodes() || [];
                if (selected.length === 0) {
                    alert('Please select nodes to pin');
                    return;
                }
                
                // Get current positions
                const positions = cosmograph.getNodePositions();
                const constraints = [];
                
                selected.forEach(node => {
                    pinnedNodes.add(node.id);
                    const nodeIndex = currentData.nodes.findIndex(n => n.id === node.id);
                    if (nodeIndex >= 0) {
                        constraints.push({
                            index: nodeIndex,
                            x: positions[nodeIndex * 2],
                            y: positions[nodeIndex * 2 + 1],
                            strength: 1.0 // Full strength to keep position fixed
                        });
                    }
                });
                
                // Apply position constraints
                if (constraints.length > 0) {
                    cosmograph.setPositionConstraints(constraints);
                }
                
                console.log(`Pinned ${selected.length} nodes. Total pinned: ${pinnedNodes.size}`);
                
                // Update visual feedback
                updatePinnedNodeStyles();
            });
            
            document.getElementById('unpin-all').addEventListener('click', () => {
                const count = pinnedNodes.size;
                pinnedNodes.clear();
                
                // Clear all position constraints
                cosmograph.setPositionConstraints([]);
                
                console.log(`Unpinned ${count} nodes`);
                
                // Update visual feedback
                updatePinnedNodeStyles();
            });
            
            document.getElementById('hide-selected').addEventListener('click', () => {
                const selected = cosmograph?.getSelectedNodes() || [];
                selected.forEach(node => hiddenNodes.add(node.id));
                
                // Filter out hidden nodes
                if (currentData) {
                    const visibleNodes = currentData.nodes.filter(n => !hiddenNodes.has(n.id));
                    const visibleEdges = currentData.edges.filter(e => 
                        !hiddenNodes.has(e.source) && !hiddenNodes.has(e.target)
                    );
                    
                    cosmograph.setData(visibleNodes, visibleEdges);
                    console.log(`Hid ${selected.length} nodes. Total hidden: ${hiddenNodes.size}`);
                }
            });
            
            document.getElementById('show-all').addEventListener('click', () => {
                if (hiddenNodes.size > 0 && currentData) {
                    hiddenNodes.clear();
                    cosmograph.setData(currentData.nodes, currentData.edges);
                    console.log('Showing all nodes');
                }
            });
            
            document.getElementById('export-selection').addEventListener('click', () => {
                const selected = cosmograph?.getSelectedNodes() || [];
                if (selected.length === 0) {
                    alert('Please select nodes to export');
                    return;
                }
                
                // Create subgraph data
                const selectedIds = new Set(selected.map(n => n.id));
                const subgraphEdges = currentData.edges.filter(e => 
                    selectedIds.has(e.source) && selectedIds.has(e.target)
                );
                
                const exportData = {
                    nodes: selected,
                    edges: subgraphEdges,
                    metadata: {
                        exportDate: new Date().toISOString(),
                        nodeCount: selected.length,
                        edgeCount: subgraphEdges.length
                    }
                };
                
                // Download as JSON
                const blob = new Blob([JSON.stringify(exportData, null, 2)], 
                    { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `graph-export-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                console.log(`Exported ${selected.length} nodes and ${subgraphEdges.length} edges`);
            });
            
            // Test button for node details
            document.getElementById('test-node-details').addEventListener('click', () => {
                console.log('Testing node details panel...');
                const testNode = {
                    id: 'test-node-123',
                    label: 'Test Node',
                    node_type: 'Entity',
                    properties: {
                        name: 'Test Entity Node',
                        summary: 'This is a test node to verify the details panel is working correctly.',
                        degree_centrality: 0.75,
                        pagerank_centrality: 0.5,
                        created_at: new Date().toISOString(),
                        source: 'Test Source'
                    }
                };
                window.showNodeDetails(testNode);
            });
            
            // Graph Layout functionality
            const layoutSelect = document.getElementById('layout-type');
            const layoutOptions = document.getElementById('layout-options');
            const applyLayoutBtn = document.getElementById('apply-layout');
            
            // Update layout options based on selected type
            layoutSelect.addEventListener('change', (e) => {
                const layoutType = e.target.value;
                console.log('Layout type changed to:', layoutType);
                updateLayoutOptions(layoutType);
            });
            
            // Apply selected layout
            applyLayoutBtn.addEventListener('click', () => {
                const layoutType = layoutSelect.value;
                console.log('Applying layout:', layoutType);
                applyGraphLayout(layoutType);
            });
            
            function updateLayoutOptions(layoutType) {
                layoutOptions.innerHTML = '';
                
                switch(layoutType) {
                    case 'hierarchical':
                        layoutOptions.innerHTML = `
                            <label class="form-label">Direction</label>
                            <select class="form-select form-select-sm mb-2" id="hier-direction">
                                <option value="TB">Top to Bottom</option>
                                <option value="BT">Bottom to Top</option>
                                <option value="LR">Left to Right</option>
                                <option value="RL">Right to Left</option>
                            </select>
                            <label class="form-label">Level Separation: <span id="level-sep-value">50</span></label>
                            <input type="range" class="form-range" id="level-separation" min="20" max="200" value="50">
                        `;
                        break;
                        
                    case 'radial':
                        layoutOptions.innerHTML = `
                            <label class="form-label">Radius: <span id="radius-value">200</span></label>
                            <input type="range" class="form-range mb-2" id="radial-radius" min="50" max="500" value="200">
                            <label class="form-label">Center Node (ID)</label>
                            <input type="text" class="form-control form-control-sm" id="radial-center" placeholder="Auto-select highest centrality">
                        `;
                        break;
                        
                    case 'circular':
                        layoutOptions.innerHTML = `
                            <label class="form-label">Radius: <span id="circle-radius-value">250</span></label>
                            <input type="range" class="form-range mb-2" id="circle-radius" min="100" max="500" value="250">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="circle-ordered">
                                <label class="form-check-label" for="circle-ordered">Order by centrality</label>
                            </div>
                        `;
                        break;
                        
                    case 'temporal':
                        layoutOptions.innerHTML = `
                            <label class="form-label">Time Axis</label>
                            <select class="form-select form-select-sm mb-2" id="time-axis">
                                <option value="horizontal">Horizontal (left to right)</option>
                                <option value="vertical">Vertical (top to bottom)</option>
                            </select>
                            <label class="form-label">Time Field</label>
                            <select class="form-select form-select-sm" id="time-field">
                                <option value="created_at">Created At</option>
                                <option value="updated_at">Updated At</option>
                                <option value="event_time">Event Time</option>
                            </select>
                        `;
                        break;
                        
                    case 'cluster':
                        layoutOptions.innerHTML = `
                            <label class="form-label">Cluster By</label>
                            <select class="form-select form-select-sm mb-2" id="cluster-by">
                                <option value="type">Node Type</option>
                                <option value="community">Community Detection</option>
                                <option value="centrality">Centrality Groups</option>
                            </select>
                            <label class="form-label">Cluster Separation: <span id="cluster-sep-value">100</span></label>
                            <input type="range" class="form-range" id="cluster-separation" min="50" max="300" value="100">
                        `;
                        break;
                        
                    case 'force':
                    default:
                        layoutOptions.innerHTML = `
                            <div class="text-muted small">Using current force-directed settings</div>
                        `;
                        break;
                }
                
                // Add event listeners to new inputs
                layoutOptions.querySelectorAll('input[type="range"]').forEach(input => {
                    input.addEventListener('input', (e) => {
                        const valueSpan = document.getElementById(e.target.id.replace('-', '-') + '-value');
                        if (valueSpan) valueSpan.textContent = e.target.value;
                    });
                });
            }
            
            function applyGraphLayout(layoutType) {
                if (!cosmograph || !currentData) {
                    console.error('No graph data available');
                    return;
                }
                
                showLoading(`Applying ${layoutType} layout...`);
                
                try {
                    switch(layoutType) {
                        case 'hierarchical':
                            applyHierarchicalLayout();
                            break;
                        case 'radial':
                            applyRadialLayout();
                            break;
                        case 'circular':
                            applyCircularLayout();
                            break;
                        case 'temporal':
                            applyTemporalLayout();
                            break;
                        case 'cluster':
                            applyClusterLayout();
                            break;
                        case 'force':
                        default:
                            // Reset to force-directed layout
                            cosmograph.setConfig({
                                ...baseConfig,
                                simulationGravity: parseFloat(document.getElementById('gravity').value),
                                simulationRepulsion: parseFloat(document.getElementById('repulsion').value),
                                simulationFriction: parseFloat(document.getElementById('friction').value)
                            });
                            cosmograph.restart();
                            break;
                    }
                } catch (error) {
                    console.error('Error applying layout:', error);
                    alert('Failed to apply layout: ' + error.message);
                } finally {
                    hideLoading();
                }
            }
            
            function applyHierarchicalLayout() {
                const direction = document.getElementById('hier-direction')?.value || 'TB';
                const levelSep = parseFloat(document.getElementById('level-separation')?.value || 50);
                
                // Create a simple hierarchical layout based on node connections
                const nodes = currentData.nodes;
                const edges = currentData.edges;
                
                // Find root nodes (nodes with no incoming edges)
                const hasIncoming = new Set(edges.map(e => e.target));
                const roots = nodes.filter(n => !hasIncoming.has(n.id));
                
                // Build adjacency list
                const adjacency = {};
                nodes.forEach(n => adjacency[n.id] = []);
                edges.forEach(e => {
                    if (adjacency[e.source]) {
                        adjacency[e.source].push(e.target);
                    }
                });
                
                // Assign levels using BFS
                const levels = {};
                const visited = new Set();
                let maxLevel = 0;
                
                roots.forEach(root => {
                    const queue = [[root.id, 0]];
                    while (queue.length > 0) {
                        const [nodeId, level] = queue.shift();
                        if (visited.has(nodeId)) continue;
                        
                        visited.add(nodeId);
                        levels[nodeId] = level;
                        maxLevel = Math.max(maxLevel, level);
                        
                        adjacency[nodeId].forEach(child => {
                            if (!visited.has(child)) {
                                queue.push([child, level + 1]);
                            }
                        });
                    }
                });
                
                // Assign unvisited nodes to bottom level
                nodes.forEach(n => {
                    if (!levels.hasOwnProperty(n.id)) {
                        levels[n.id] = maxLevel + 1;
                    }
                });
                
                // Position nodes
                const levelCounts = {};
                const levelIndices = {};
                
                Object.values(levels).forEach(level => {
                    levelCounts[level] = (levelCounts[level] || 0) + 1;
                    levelIndices[level] = 0;
                });
                
                const positions = nodes.map(node => {
                    const level = levels[node.id];
                    const index = levelIndices[level]++;
                    const count = levelCounts[level];
                    
                    let x, y;
                    if (direction === 'TB' || direction === 'BT') {
                        x = (index - (count - 1) / 2) * levelSep * 2;
                        y = level * levelSep * 3;
                        if (direction === 'BT') y = -y;
                    } else {
                        x = level * levelSep * 3;
                        y = (index - (count - 1) / 2) * levelSep * 2;
                        if (direction === 'RL') x = -x;
                    }
                    
                    return [x, y];
                });
                
                // Since setNodePositions doesn't exist, we need to use a different approach
                // We'll create new node data with x,y coordinates
                const nodesWithPositions = nodes.map((node, i) => ({
                    ...node,
                    x: positions[i][0],
                    y: positions[i][1]
                }));
                
                // Set the data with positioned nodes
                cosmograph.setData(nodesWithPositions, edges);
                
                // Disable simulation temporarily to keep positions
                cosmograph.setConfig({
                    ...baseConfig,
                    simulationGravity: 0,
                    simulationRepulsion: 0,
                    simulationCenter: 0,
                    disableSimulation: true
                });
                
                setTimeout(() => {
                    cosmograph.setConfig({
                        ...baseConfig,
                        simulationGravity: 0.01,
                        simulationRepulsion: 0.1,
                        simulationCenter: 0.1,
                        disableSimulation: false
                    });
                }, 500);
            }
            
            function applyRadialLayout() {
                const radius = parseFloat(document.getElementById('radial-radius')?.value || 200);
                const centerNodeId = document.getElementById('radial-center')?.value;
                
                // Find center node (highest centrality if not specified)
                let centerNode;
                if (centerNodeId) {
                    centerNode = currentData.nodes.find(n => n.id === centerNodeId);
                } else {
                    centerNode = currentData.nodes.reduce((max, node) => 
                        (node.properties?.degree_centrality || 0) > (max.properties?.degree_centrality || 0) ? node : max
                    );
                }
                
                if (!centerNode) {
                    alert('Center node not found');
                    return;
                }
                
                // Build distance map from center using BFS
                const distances = {};
                const adjacency = {};
                currentData.nodes.forEach(n => adjacency[n.id] = new Set());
                currentData.edges.forEach(e => {
                    adjacency[e.source].add(e.target);
                    adjacency[e.target].add(e.source);
                });
                
                const queue = [[centerNode.id, 0]];
                const visited = new Set();
                let maxDistance = 0;
                
                while (queue.length > 0) {
                    const [nodeId, distance] = queue.shift();
                    if (visited.has(nodeId)) continue;
                    
                    visited.add(nodeId);
                    distances[nodeId] = distance;
                    maxDistance = Math.max(maxDistance, distance);
                    
                    adjacency[nodeId].forEach(neighbor => {
                        if (!visited.has(neighbor)) {
                            queue.push([neighbor, distance + 1]);
                        }
                    });
                }
                
                // Position nodes in concentric circles
                const positions = currentData.nodes.map(node => {
                    const distance = distances[node.id] || maxDistance + 1;
                    const nodesAtDistance = currentData.nodes.filter(n => 
                        (distances[n.id] || maxDistance + 1) === distance
                    );
                    const index = nodesAtDistance.indexOf(node);
                    const count = nodesAtDistance.length;
                    
                    if (distance === 0) {
                        return [0, 0];
                    }
                    
                    const angle = (index / count) * 2 * Math.PI;
                    const r = radius * (distance / (maxDistance + 1));
                    
                    return [
                        r * Math.cos(angle),
                        r * Math.sin(angle)
                    ];
                });
                
                // Create nodes with positions
                const nodesWithPositions = currentData.nodes.map((node, i) => ({
                    ...node,
                    x: positions[i][0],
                    y: positions[i][1]
                }));
                
                cosmograph.setData(nodesWithPositions, currentData.edges);
                cosmograph.setConfig({
                    ...baseConfig,
                    simulationGravity: 0,
                    simulationRepulsion: 0.5,
                    simulationCenter: 0,
                    disableSimulation: false
                });
            }
            
            function applyCircularLayout() {
                const radius = parseFloat(document.getElementById('circle-radius')?.value || 250);
                const orderByCentrality = document.getElementById('circle-ordered')?.checked;
                
                let nodes = [...currentData.nodes];
                
                if (orderByCentrality) {
                    nodes.sort((a, b) => 
                        (b.properties?.degree_centrality || 0) - (a.properties?.degree_centrality || 0)
                    );
                }
                
                const positions = nodes.map((node, index) => {
                    const angle = (index / nodes.length) * 2 * Math.PI;
                    return [
                        radius * Math.cos(angle),
                        radius * Math.sin(angle)
                    ];
                });
                
                // Create nodes with positions
                const nodesWithPositions = nodes.map((node, i) => ({
                    ...node,
                    x: positions[i][0],
                    y: positions[i][1]
                }));
                
                cosmograph.setData(nodesWithPositions, currentData.edges);
                cosmograph.setConfig({
                    ...baseConfig,
                    simulationGravity: 0,
                    simulationRepulsion: 0.3,
                    simulationCenter: 0,
                    disableSimulation: false
                });
            }
            
            function applyTemporalLayout() {
                const axis = document.getElementById('time-axis')?.value || 'horizontal';
                const timeField = document.getElementById('time-field')?.value || 'created_at';
                
                // Extract timestamps
                const times = currentData.nodes.map(node => {
                    const timeStr = node.properties?.[timeField];
                    return timeStr ? new Date(timeStr).getTime() : Date.now();
                });
                
                const minTime = Math.min(...times);
                const maxTime = Math.max(...times);
                const timeRange = maxTime - minTime || 1;
                
                // Group nodes by time buckets
                const buckets = {};
                currentData.nodes.forEach((node, i) => {
                    const time = times[i];
                    const bucket = Math.floor((time - minTime) / (timeRange / 20)); // 20 time buckets
                    if (!buckets[bucket]) buckets[bucket] = [];
                    buckets[bucket].push(i);
                });
                
                // Position nodes
                const positions = new Float32Array(currentData.nodes.length * 2);
                Object.entries(buckets).forEach(([bucket, indices]) => {
                    const bucketTime = parseInt(bucket);
                    const timePosition = (bucketTime / 20) * 600 - 300; // -300 to 300
                    
                    indices.forEach((nodeIndex, i) => {
                        if (axis === 'horizontal') {
                            positions[nodeIndex * 2] = timePosition;
                            positions[nodeIndex * 2 + 1] = (i - indices.length / 2) * 30;
                        } else {
                            positions[nodeIndex * 2] = (i - indices.length / 2) * 30;
                            positions[nodeIndex * 2 + 1] = timePosition;
                        }
                    });
                });
                
                // Create nodes with positions
                const nodesWithPositions = currentData.nodes.map((node, i) => ({
                    ...node,
                    x: positions[i][0],
                    y: positions[i][1]
                }));
                
                cosmograph.setData(nodesWithPositions, currentData.edges);
                cosmograph.setConfig({
                    ...baseConfig,
                    simulationGravity: 0,
                    simulationRepulsion: 0.5,
                    simulationCenter: 0,
                    disableSimulation: false
                });
            }
            
            function applyClusterLayout() {
                const clusterBy = document.getElementById('cluster-by')?.value || 'type';
                const separation = parseFloat(document.getElementById('cluster-separation')?.value || 100);
                
                // Group nodes by cluster criteria
                const clusters = {};
                currentData.nodes.forEach((node, i) => {
                    let clusterId;
                    
                    switch(clusterBy) {
                        case 'type':
                            clusterId = node.node_type || 'unknown';
                            break;
                        case 'centrality':
                            const centrality = node.properties?.degree_centrality || 0;
                            clusterId = centrality > 0.7 ? 'high' : centrality > 0.3 ? 'medium' : 'low';
                            break;
                        case 'community':
                            // Simple community detection based on shared neighbors
                            clusterId = detectCommunity(node, i);
                            break;
                        default:
                            clusterId = 'default';
                    }
                    
                    if (!clusters[clusterId]) clusters[clusterId] = [];
                    clusters[clusterId].push(i);
                });
                
                // Position clusters in a grid
                const clusterKeys = Object.keys(clusters);
                const gridSize = Math.ceil(Math.sqrt(clusterKeys.length));
                const positions = new Float32Array(currentData.nodes.length * 2);
                
                clusterKeys.forEach((clusterId, clusterIndex) => {
                    const row = Math.floor(clusterIndex / gridSize);
                    const col = clusterIndex % gridSize;
                    const centerX = (col - gridSize / 2) * separation * 2;
                    const centerY = (row - gridSize / 2) * separation * 2;
                    
                    const nodeIndices = clusters[clusterId];
                    const radius = Math.sqrt(nodeIndices.length) * 10;
                    
                    nodeIndices.forEach((nodeIndex, i) => {
                        const angle = (i / nodeIndices.length) * 2 * Math.PI;
                        positions[nodeIndex * 2] = centerX + radius * Math.cos(angle);
                        positions[nodeIndex * 2 + 1] = centerY + radius * Math.sin(angle);
                    });
                });
                
                // Create nodes with positions
                const nodesWithPositions = currentData.nodes.map((node, i) => ({
                    ...node,
                    x: positions[i * 2],
                    y: positions[i * 2 + 1]
                }));
                
                cosmograph.setData(nodesWithPositions, currentData.edges);
                cosmograph.setConfig({
                    ...baseConfig,
                    simulationGravity: 0.05,
                    simulationRepulsion: 0.8,
                    simulationCenter: 0,
                    disableSimulation: false
                });
            }
            
            function detectCommunity(node, nodeIndex) {
                // Simple community detection based on shared neighbors
                const neighbors = new Set();
                currentData.edges.forEach(e => {
                    if (e.source === node.id) neighbors.add(e.target);
                    if (e.target === node.id) neighbors.add(e.source);
                });
                
                // Use first few characters of neighbors as community ID
                const neighborList = Array.from(neighbors).sort();
                return neighborList.slice(0, 3).join(',') || 'isolated';
            }
            
            // Initialize layout options
            updateLayoutOptions('force');
        }
        
        // Helper function to get node color string
        function getNodeColorString(node) {
            const colorScheme = document.getElementById('node-color-scheme')?.value || 'type';
            
            switch(colorScheme) {
                case 'type':
                    const typeColors = {
                        'Entity': '#4ecdc4',
                        'Episodic': '#f77f00',
                        'Agent': '#ef476f',
                        'Community': '#06ffa5'
                    };
                    return typeColors[node.node_type] || '#999999';
                    
                case 'centrality':
                    const centrality = node.properties?.degree_centrality || 0;
                    const intensity = Math.floor(centrality * 255);
                    return `rgb(${intensity}, ${100}, ${255 - intensity})`;
                    
                case 'pagerank':
                    const pagerank = node.properties?.pagerank_centrality || 0;
                    const pr_intensity = Math.floor(pagerank * 255);
                    return `rgb(${pr_intensity}, ${pr_intensity}, ${255})`;
                    
                default:
                    return '#4ecdc4';
            }
        }
        
        // Helper function to update pinned node visual styles
        function updatePinnedNodeStyles() {
            if (!cosmograph || !currentData) return;
            
            // Update node colors to show pinned status
            const nodeColors = currentData.nodes.map(node => {
                if (pinnedNodes.has(node.id)) {
                    // Pinned nodes get a special color (red tint)
                    return [255, 100, 100, 255];
                } else {
                    // Use default color scheme
                    return getNodeColor(node);
                }
            });
            
            // Since setNodeColor might not exist, update via config
            cosmograph.setConfig({
                ...baseConfig,
                nodeColor: (node) => {
                    if (pinnedNodes.has(node.id)) {
                        return 'rgba(255, 100, 100, 1)';
                    }
                    return getNodeColorString(node);
                }
            });
        }
        
        // Add expand/collapse functionality
        function addExpandCollapseControls() {
            const controlsDiv = document.createElement('div');
            controlsDiv.innerHTML = `
                <div class="card-header mt-3">
                    <h6 class="mb-0">🔄 Expand/Collapse</h6>
                </div>
                <div class="card-body">
                    <div class="mb-2">
                        <button id="collapse-selected" class="btn btn-sm btn-outline-secondary w-100" title="Collapse selected nodes">
                            ➖ Collapse Selected
                        </button>
                    </div>
                    <div class="mb-2">
                        <button id="expand-all" class="btn btn-sm btn-outline-secondary w-100" title="Expand all collapsed nodes">
                            ➕ Expand All
                        </button>
                    </div>
                    <div class="mb-2">
                        <small class="text-muted">
                            <span id="collapsed-count">0</span> nodes collapsed
                        </small>
                    </div>
                </div>
            `;
            
            // Insert after quick actions
            const quickActions = document.querySelector('#export-selection').parentElement.parentElement;
            quickActions.parentElement.insertBefore(controlsDiv, quickActions.nextSibling);
            
            // Add event listeners
            document.getElementById('collapse-selected').addEventListener('click', () => {
                const selected = cosmograph?.getSelectedNodes() || [];
                if (selected.length === 0) {
                    alert('Please select nodes to collapse');
                    return;
                }
                
                selected.forEach(node => {
                    collapsedNodes.add(node.id);
                    
                    // Find and hide edges connected to this node
                    const connectedEdges = currentData.edges.filter(e => 
                        e.source === node.id || e.target === node.id
                    );
                    collapsedEdges.set(node.id, connectedEdges);
                });
                
                // Update visualization
                updateCollapsedView();
                document.getElementById('collapsed-count').textContent = collapsedNodes.size;
            });
            
            document.getElementById('expand-all').addEventListener('click', () => {
                collapsedNodes.clear();
                collapsedEdges.clear();
                
                // Restore full graph
                if (currentData) {
                    cosmograph.setData(currentData.nodes, currentData.edges);
                }
                document.getElementById('collapsed-count').textContent = '0';
            });
        }
        
        function updateCollapsedView() {
            if (!currentData || !cosmograph) return;
            
            // Filter out collapsed nodes and their edges
            const visibleNodes = currentData.nodes.map(node => {
                if (collapsedNodes.has(node.id)) {
                    // Create a placeholder node
                    return {
                        ...node,
                        label: `[${node.label}]`,
                        properties: {
                            ...node.properties,
                            collapsed: true
                        }
                    };
                }
                return node;
            });
            
            const visibleEdges = currentData.edges.filter(edge => {
                // Hide edges from collapsed nodes
                return !collapsedNodes.has(edge.source) && !collapsedNodes.has(edge.target);
            });
            
            cosmograph.setData(visibleNodes, visibleEdges);
        }
        
        // Call this after DOM is ready
        setTimeout(addExpandCollapseControls, 100);
        
        function showLoading(message = 'Loading...') {
            document.getElementById('loading-overlay').classList.add('active');
            document.getElementById('loading-status').textContent = message;
        }
        
        function hideLoading() {
            document.getElementById('loading-overlay').classList.remove('active');
        }
        
        async function loadStats() {
            try {
                const response = await fetch('/api/stats');
                const data = await response.json();
                
                document.getElementById('total-nodes').textContent = data.total_nodes.toLocaleString();
                document.getElementById('total-edges').textContent = data.total_edges.toLocaleString();
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }
        
        window.visualize = async function() {
            console.log('=== VISUALIZE BUTTON CLICKED ===');
            console.log('visualize() called at', new Date().toISOString());
            const queryType = document.getElementById('query-type').value;
            const limit = document.getElementById('node-limit').value;
            console.log('Query type:', queryType, 'Limit:', limit);
            
            // Disable button during loading
            const visualizeBtn = document.getElementById('visualize-btn');
            const originalText = visualizeBtn.textContent;
            visualizeBtn.disabled = true;
            visualizeBtn.textContent = 'Loading...';
            
            showLoading('Fetching graph data from FalkorDB...');
            
            try {
                const params = new URLSearchParams({
                    query_type: queryType,
                    limit: parseInt(limit),
                    offset: 0
                });
                
                console.log('Fetching from API with params:', params.toString());
                const response = await fetch('/api/visualize?' + params);
                console.log('API response status:', response.status);
                const data = await response.json();
                console.log('API data received:', data);
                
                if (data.error) {
                    alert('Error: ' + data.error);
                    return;
                }
                
                document.getElementById('query-time').textContent = data.execution_time_ms;
                
                showLoading('Processing nodes and edges...');
                await processAndRenderGraph(data.data);
                
            } catch (error) {
                console.error('Error visualizing:', error);
                alert('Error visualizing graph');
            } finally {
                hideLoading();
                // Re-enable button
                visualizeBtn.disabled = false;
                visualizeBtn.textContent = originalText;
                console.log('=== VISUALIZE COMPLETE ===');
            }
        }
        
        window.loadEntireGraph = async function() {
            console.log('=== LOAD ENTIRE GRAPH BUTTON CLICKED ===');
            console.log('loadEntireGraph() called at', new Date().toISOString());
            
            if (!confirm('⚡ Loading the entire graph will utilize GPU acceleration. Continue?')) {
                console.log('User cancelled entire graph load');
                return;
            }
            
            // Disable button during loading
            const loadBtn = document.getElementById('load-entire-graph-btn');
            const originalText = loadBtn.textContent;
            loadBtn.disabled = true;
            loadBtn.textContent = 'Loading...';
            
            showLoading('Fetching entire graph from FalkorDB...');
            
            try {
                const params = new URLSearchParams({
                    query_type: 'entire_graph',
                    limit: 100000,
                    offset: 0
                });
                
                console.log('Fetching from API with params:', params.toString());
                const response = await fetch('/api/visualize?' + params);
                console.log('API response status:', response.status);
                const data = await response.json();
                console.log('API data received:', data);
                
                if (data.error) {
                    alert('Error: ' + data.error);
                    return;
                }
                
                document.getElementById('query-time').textContent = data.execution_time_ms;
                document.getElementById('node-limit').value = data.data.nodes.length;
                
                showLoading(`Processing ${data.data.nodes.length} nodes and ${data.data.edges.length} edges...`);
                await processAndRenderGraph(data.data);
                
            } catch (error) {
                console.error('Error loading entire graph:', error);
                alert('Error loading entire graph');
            } finally {
                hideLoading();
                // Re-enable button
                loadBtn.disabled = false;
                loadBtn.textContent = originalText;
                console.log('=== LOAD ENTIRE GRAPH COMPLETE ===');
            }
        }
        
        async function processAndRenderGraph(data) {
            console.log('processAndRenderGraph called with data:', data);
            currentData = data;
            
            // Clear and rebuild node data map
            nodeDataMap.clear();
            
            // Transform nodes for Cosmograph format
            const nodes = data.nodes.map((node) => {
                // Store original node data in our map
                nodeDataMap.set(node.id, node);
                
                return {
                    id: node.id,
                    ...node // Include all properties
                };
            });
            
            console.log('Node data map created with', nodeDataMap.size, 'nodes');
            
            // Transform edges to use source/target instead of from/to
            const links = data.edges.map(edge => ({
                source: edge.from,
                target: edge.to,
                ...edge
            }));
            
            // Update stats
            document.getElementById('rendered-nodes').textContent = nodes.length.toLocaleString();
            document.getElementById('rendered-edges').textContent = links.length.toLocaleString();
            
            // Set data to cosmograph
            showLoading('Initializing GPU renderer...');
            
            console.log('Setting data - nodes:', nodes.length, 'links:', links.length);
            console.log('Sample node:', nodes[0]);
            console.log('Sample link:', links[0]);
            
            try {
                console.log('Setting new data...');
                cosmograph.setData(nodes, links);
                console.log('Data set successfully');
                
                // Hide loading overlay
                hideLoading();
                
                // Fit view after data is set
                setTimeout(() => {
                    console.log('Fitting view...');
                    cosmograph.fitView();
                    console.log('View fitted');
                }, 250);
                
                // Update render stats
                const renderTime = 10; // Placeholder
                document.getElementById('render-time').textContent = renderTime.toFixed(1);
                
                // Estimate GPU memory
                if (currentData) {
                    const memoryMB = estimateGPUMemory(currentData);
                    document.getElementById('gpu-memory').textContent = `~${memoryMB.toFixed(1)} MB`;
                }
            } catch (error) {
                console.error('Error setting data to cosmograph:', error);
                hideLoading();
                alert('Error rendering graph: ' + error.message);
            }
        }
        
        window.showNodeDetails = function(node) {
            console.log('showNodeDetails called with node:', node);
            console.log('Node keys:', Object.keys(node));
            console.log('Node type:', node.node_type);
            console.log('Node properties:', node.properties);
            
            // Create or update node details panel
            let detailsPanel = document.getElementById('node-details');
            if (!detailsPanel) {
                console.log('Creating new node details panel');
                detailsPanel = document.createElement('div');
                detailsPanel.id = 'node-details';
                detailsPanel.className = 'node-details-panel';
                document.body.appendChild(detailsPanel);
                console.log('Panel created and appended to body');
            } else {
                console.log('Using existing node details panel');
            }
            
            // Properties might be at root level or nested under 'properties'
            // Check if properties are nested or at root level
            const hasNestedProperties = node.properties && typeof node.properties === 'object';
            const props = hasNestedProperties ? node.properties : node;
            console.log('Has nested properties:', hasNestedProperties);
            console.log('Using props:', props);
            
            // Format centrality scores - check both nested and root level
            let centralityHtml = '';
            const centralityMetrics = ['degree_centrality', 'pagerank_centrality', 'betweenness_centrality', 'importance_centrality'];
            const hasCentrality = centralityMetrics.some(metric => 
                props[metric] !== undefined || node[metric] !== undefined
            );
            
            if (hasCentrality) {
                centralityHtml = '<div class="centrality-section mt-3"><h6>📊 Centrality Metrics</h6>';
                centralityMetrics.forEach(metric => {
                    // Check both locations for the metric
                    const value = props[metric] !== undefined ? props[metric] : node[metric];
                    if (value !== undefined) {
                        const numValue = parseFloat(value);
                        const percentage = Math.min(numValue * 100, 100);
                        const label = metric.replace('_centrality', '').replace('_', ' ');
                        centralityHtml += `
                            <div class="mb-2">
                                <small class="text-muted">${label.charAt(0).toUpperCase() + label.slice(1)}</small>
                                <div class="progress" style="height: 10px;">
                                    <div class="progress-bar bg-info" style="width: ${percentage}%"></div>
                                </div>
                                <small class="text-muted">${numValue.toFixed(4)}</small>
                            </div>
                        `;
                    }
                });
                centralityHtml += '</div>';
            }
            
            // Format summary if available - check both locations
            const summary = props.summary || node.summary;
            const summaryHtml = summary ? `
                <div class="summary-section mt-3">
                    <h6>📝 Summary</h6>
                    <div class="text-muted small">${summary}</div>
                </div>
            ` : '';
            
            // Format JSON content for episodic nodes
            let jsonContentHtml = '';
            const content = props.content || node.content;
            if (node.node_type === 'Episodic' && content) {
                try {
                    const parsedContent = typeof content === 'string' ? JSON.parse(content) : content;
                    jsonContentHtml = `
                        <div class="json-section mt-3">
                            <h6>📄 Content <button class="btn btn-sm btn-link" onclick="toggleJsonContent()">Toggle</button></h6>
                            <pre id="json-content" style="display: none; max-height: 300px; overflow-y: auto; font-size: 11px; background: rgba(40,40,40,0.5); padding: 10px; border-radius: 4px;">
${JSON.stringify(parsedContent, null, 2)}
                            </pre>
                        </div>
                    `;
                } catch (e) {
                    console.error('Error parsing JSON content:', e);
                }
            }
            
            // Format timestamps
            const formatDate = (dateStr) => {
                if (!dateStr) return 'N/A';
                const date = new Date(dateStr);
                return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
            };
            
            // Build HTML with fallbacks - check all possible locations
            const nodeName = node.label || props.name || node.name || props.label || 'Unnamed Node';
            const nodeType = node.node_type || node.type || props.node_type || props.type || 'Unknown';
            const nodeId = node.id || props.id || 'no-id';
            
            // Check both locations for timestamps
            const created_at = props.created_at || node.created_at;
            const valid_at = props.valid_at || node.valid_at;
            const source = props.source || node.source;
            
            detailsPanel.innerHTML = `
                <div class="node-details-header">
                    <h5>Node Details</h5>
                    <button class="btn-close" onclick="window.closeNodeDetails()">×</button>
                </div>
                <div class="node-details-content">
                    <div><strong>Name:</strong> ${nodeName}</div>
                    <div><strong>Type:</strong> <span class="badge bg-${getNodeTypeBadgeColor(nodeType)}">${nodeType}</span></div>
                    <div><strong>ID:</strong> <small class="text-muted">${nodeId}</small></div>
                    ${created_at ? `<div><strong>Created:</strong> ${formatDate(created_at)}</div>` : ''}
                    ${valid_at ? `<div><strong>Valid At:</strong> ${formatDate(valid_at)}</div>` : ''}
                    ${source ? `<div><strong>Source:</strong> ${source}</div>` : ''}
                    ${summaryHtml}
                    ${centralityHtml}
                    ${jsonContentHtml}
                    
                    <!-- Debug info -->
                    <div class="mt-3 text-muted small">
                        <details>
                            <summary>Debug Info (click to expand)</summary>
                            <pre style="font-size: 10px; max-height: 200px; overflow-y: auto;">
${JSON.stringify(node, null, 2)}
                            </pre>
                        </details>
                    </div>
                </div>
            `;
            
            // Make the panel visible
            detailsPanel.style.display = 'block';
            console.log('Node details panel should now be visible');
            
            // Add toggle function for JSON content
            window.toggleJsonContent = function() {
                const jsonEl = document.getElementById('json-content');
                if (jsonEl) {
                    jsonEl.style.display = jsonEl.style.display === 'none' ? 'block' : 'none';
                }
            };
            
            // Add close handler
            window.closeNodeDetails = function() {
                const panel = document.getElementById('node-details');
                if (panel) {
                    panel.style.display = 'none';
                }
            };
        }
        
        function getNodeTypeBadgeColor(type) {
            const colors = {
                'Entity': 'danger',
                'Episodic': 'info',
                'Agent': 'warning'
            };
            return colors[type] || 'secondary';
        }
        
        window.togglePanel = function() {
            const panel = document.querySelector('.control-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
        
        window.toggleSimulation = function() {
            isPaused = !isPaused;
            
            if (isPaused) {
                cosmograph.pause();
                document.getElementById('pause-simulation').textContent = 'Resume';
            } else {
                cosmograph.start();
                document.getElementById('pause-simulation').textContent = 'Pause';
            }
        }
        
        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            
            if (currentTime >= lastTime + 1000) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = fps;
                
                frameCount = 0;
                lastTime = currentTime;
            }
            
            requestAnimationFrame(updateFPS);
        }
        
        function estimateGPUMemory(data) {
            // Rough estimate: 
            // Each node: position (2 floats), color (1 float), size (1 float) = 16 bytes
            // Each edge: source/target (2 ints) = 8 bytes
            const nodeMemory = data.nodes.length * 16;
            const edgeMemory = data.edges.length * 8;
            return (nodeMemory + edgeMemory) / (1024 * 1024);
        }
        
        function applyFilters() {
            if (!currentData) return;
            
            // Basic filters
            const entityChecked = document.getElementById('filter-entity').checked;
            const episodicChecked = document.getElementById('filter-episodic').checked;
            const agentChecked = document.getElementById('filter-agent').checked;
            const communityChecked = document.getElementById('filter-community')?.checked ?? true;
            
            // Metric filters
            const centralityThreshold = parseInt(document.getElementById('centrality-threshold').value) / 100;
            const pageRankThreshold = parseInt(document.getElementById('pagerank-threshold').value) / 100;
            const minDegree = parseInt(document.getElementById('min-degree').value || '0');
            const maxDegree = parseInt(document.getElementById('max-degree').value || '999999');
            
            // Time filters
            const createdAfter = document.getElementById('created-after').value ? 
                new Date(document.getElementById('created-after').value) : null;
            const createdBefore = document.getElementById('created-before').value ? 
                new Date(document.getElementById('created-before').value) : null;
            
            // Filter nodes
            const filteredNodes = currentData.nodes.filter(node => {
                // Type filter
                if (node.node_type === 'Entity' && !entityChecked) return false;
                if (node.node_type === 'Episodic' && !episodicChecked) return false;
                if (node.node_type === 'Agent' && !agentChecked) return false;
                if (node.node_type === 'Community' && !communityChecked) return false;
                
                // Metric filters
                const degree = node.properties?.degree_centrality || 0;
                const pagerank = node.properties?.pagerank_centrality || 0;
                const nodeDegree = node.properties?.degree_in_centrality + node.properties?.degree_out_centrality || 0;
                
                if (degree < centralityThreshold) return false;
                if (pagerank < pageRankThreshold) return false;
                if (nodeDegree < minDegree || nodeDegree > maxDegree) return false;
                
                // Time filter
                if (createdAfter || createdBefore) {
                    const createdAt = new Date(node.properties?.created_at);
                    if (createdAfter && createdAt < createdAfter) return false;
                    if (createdBefore && createdAt > createdBefore) return false;
                }
                
                // Search filter
                if (searchTerm) {
                    const name = (node.label || node.properties?.name || '').toLowerCase();
                    const summary = (node.properties?.summary || '').toLowerCase();
                    if (!name.includes(searchTerm) && !summary.includes(searchTerm)) {
                        return false;
                    }
                }
                
                return true;
            });
            
            // Get filtered node IDs
            const nodeIds = new Set(filteredNodes.map(n => n.id));
            
            // Filter edges to only include those between filtered nodes
            const filteredEdges = currentData.edges.filter(edge => 
                nodeIds.has(edge.from) && nodeIds.has(edge.to)
            );
            
            // Update visualization
            const filteredData = {
                nodes: filteredNodes,
                edges: filteredEdges,
                stats: currentData.stats
            };
            
            processAndRenderGraph(filteredData);
            
            // Update stats
            document.getElementById('rendered-nodes').textContent = 
                `${filteredNodes.length} / ${currentData.nodes.length}`;
            document.getElementById('rendered-edges').textContent = 
                `${filteredEdges.length} / ${currentData.edges.length}`;
        }
        
        function resetFilters() {
            document.getElementById('filter-entity').checked = true;
            document.getElementById('filter-episodic').checked = true;
            document.getElementById('filter-agent').checked = true;
            document.getElementById('centrality-threshold').value = 0;
            document.getElementById('centrality-value').textContent = '0';
            document.getElementById('node-search').value = '';
            
            if (currentData) {
                processAndRenderGraph(currentData);
            }
        }
        
        function toggleCustomPhysics() {
            customPhysicsEnabled = !customPhysicsEnabled;
            const btn = document.getElementById('toggle-custom-physics');
            btn.textContent = customPhysicsEnabled ? 'Disable Custom Physics' : 'Enable Custom Physics';
            btn.classList.toggle('btn-success');
            btn.classList.toggle('btn-secondary');
        }
        
        function applyExplosion() {
            if (cosmograph && currentData) {
                // Apply random velocities to simulate explosion
                console.log('Applying explosion effect...');
                cosmograph.setZoomLevel(0.5, 1000); // Zoom out
                setTimeout(() => {
                    cosmograph.fitView(1000); // Fit view after explosion
                }, 1500);
            }
        }
        
        function randomizePositions() {
            if (cosmograph) {
                // Restart simulation to randomize positions
                cosmograph.restart();
            }
        }
        
        function updateNodeColors(scheme) {
            if (!cosmograph || !currentData) return;
            
            console.log('Updating node colors with scheme:', scheme);
            
            let colorFunction;
            
            switch(scheme) {
                case 'centrality':
                    colorFunction = (node) => {
                        const centrality = node.properties?.degree_centrality || 0;
                        const hue = 240 - (centrality * 240); // Blue to red
                        return `hsl(${hue}, 70%, 50%)`;
                    };
                    break;
                    
                case 'degree':
                    colorFunction = (node) => {
                        const degree = node.degree || 0;
                        const maxDegree = Math.max(...currentData.nodes.map(n => n.degree || 0));
                        const intensity = degree / maxDegree;
                        return `hsl(${120 - intensity * 120}, 70%, 50%)`; // Green to red
                    };
                    break;
                    
                case 'pagerank':
                    colorFunction = (node) => {
                        const pagerank = node.properties?.pagerank_centrality || 0;
                        const hue = 60 + (pagerank * 300); // Yellow to purple
                        return `hsl(${hue}, 70%, 50%)`;
                    };
                    break;
                    
                case 'custom':
                    colorFunction = () => '#4ecdc4'; // Default teal
                    break;
                    
                case 'type':
                default:
                    // Original color by type function
                    colorFunction = (node) => {
                        const typeColors = {
                            'Entity': '#ff6b6b',
                            'Episodic': '#4ecdc4',
                            'Community': '#45b7d1',
                            'default': '#b3b3b3'
                        };
                        return typeColors[node.node_type] || typeColors.default;
                    };
                    break;
            }
            
            cosmograph.setConfig({ ...baseConfig, nodeColor: colorFunction });
        }
        
        function searchNodes(searchTerm) {
            if (!currentData || !searchTerm) return;
            
            const results = [];
            const searchLower = searchTerm.toLowerCase();
            
            // Search through nodes
            currentData.nodes.forEach(node => {
                const label = (node.label || '').toLowerCase();
                const name = (node.properties?.name || '').toLowerCase();
                const summary = (node.properties?.summary || '').toLowerCase();
                
                if (label.includes(searchLower) || 
                    name.includes(searchLower) || 
                    summary.includes(searchLower)) {
                    results.push({
                        node: node,
                        score: label === searchLower ? 3 : 
                               name === searchLower ? 2 : 1
                    });
                }
            });
            
            // Sort by relevance and limit results
            results.sort((a, b) => b.score - a.score);
            const topResults = results.slice(0, 10);
            
            // Display results
            const resultsDiv = document.getElementById('search-results');
            resultsDiv.innerHTML = '';
            
            if (topResults.length === 0) {
                resultsDiv.innerHTML = '<div class="text-muted p-2">No results found</div>';
            } else {
                topResults.forEach(result => {
                    const div = document.createElement('div');
                    div.className = 'search-result-item p-2';
                    div.style.cursor = 'pointer';
                    div.innerHTML = `
                        <strong>${result.node.label}</strong><br>
                        <small class="text-muted">${result.node.node_type}</small>
                    `;
                    div.addEventListener('click', () => {
                        // Select and zoom to node
                        cosmograph.selectNodes([result.node]);
                        cosmograph.zoomToNode(result.node);
                        showNodeDetails(result.node);
                        resultsDiv.style.display = 'none';
                    });
                    resultsDiv.appendChild(div);
                });
            }
            
            resultsDiv.style.display = 'block';
        }
        
        function findPathBetweenNodes() {
            const selectedNodes = cosmograph?.getSelectedNodes();
            if (!selectedNodes || selectedNodes.length !== 2) {
                alert('Please select exactly 2 nodes to find path between them');
                return;
            }
            
            showLoading('Finding shortest path...');
            
            try {
                const startId = selectedNodes[0].id;
                const endId = selectedNodes[1].id;
                const path = findShortestPath(startId, endId);
                
                if (path && path.length > 0) {
                    // Highlight path nodes and edges
                    const pathNodeIds = new Set(path);
                    const pathNodes = currentData.nodes.filter(n => pathNodeIds.has(n.id));
                    
                    // Find edges in the path
                    const pathEdges = [];
                    for (let i = 0; i < path.length - 1; i++) {
                        const edge = currentData.edges.find(e => 
                            (e.source === path[i] && e.target === path[i+1]) ||
                            (e.target === path[i] && e.source === path[i+1])
                        );
                        if (edge) pathEdges.push(edge);
                    }
                    
                    // Select path nodes
                    cosmograph.selectNodes(pathNodes);
                    
                    // Show path info
                    const pathInfo = `Path found: ${path.length} nodes\n${path.map(id => {
                        const node = currentData.nodes.find(n => n.id === id);
                        return node?.label || id;
                    }).join(' → ')}`;
                    
                    console.log(pathInfo);
                    
                    // Create temporary info panel
                    showPathInfo(pathInfo, pathEdges.length);
                } else {
                    alert('No path found between selected nodes');
                }
            } catch (error) {
                console.error('Error finding path:', error);
                alert('Error finding path: ' + error.message);
            } finally {
                hideLoading();
            }
        }
        
        function findShortestPath(startId, endId) {
            // BFS implementation for shortest path
            const adjacency = {};
            currentData.nodes.forEach(n => adjacency[n.id] = new Set());
            currentData.edges.forEach(e => {
                // Ensure both nodes exist in adjacency before adding edges
                if (!adjacency[e.source]) adjacency[e.source] = new Set();
                if (!adjacency[e.target]) adjacency[e.target] = new Set();
                
                adjacency[e.source].add(e.target);
                adjacency[e.target].add(e.source);
            });
            
            const queue = [[startId, [startId]]];
            const visited = new Set();
            
            while (queue.length > 0) {
                const [currentId, path] = queue.shift();
                
                if (currentId === endId) {
                    return path;
                }
                
                if (visited.has(currentId)) continue;
                visited.add(currentId);
                
                for (const neighbor of adjacency[currentId]) {
                    if (!visited.has(neighbor)) {
                        queue.push([neighbor, [...path, neighbor]]);
                    }
                }
            }
            
            return null;
        }
        
        function showPathInfo(pathInfo, edgeCount) {
            const infoPanel = document.createElement('div');
            infoPanel.style.cssText = `
                position: fixed;
                top: 60px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(20, 20, 20, 0.95);
                padding: 15px;
                border-radius: 8px;
                border: 1px solid #4ecdc4;
                max-width: 600px;
                z-index: 10000;
                animation: slideIn 0.3s ease-out;
            `;
            
            infoPanel.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: start;">
                    <div>
                        <h6 style="color: #4ecdc4; margin: 0 0 10px 0;">Path Found</h6>
                        <pre style="margin: 0; font-size: 12px; color: #ddd; white-space: pre-wrap;">${pathInfo}</pre>
                        <small style="color: #999;">Edges in path: ${edgeCount}</small>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="background: none; border: none; color: #999; font-size: 20px; cursor: pointer; margin-left: 20px;">×</button>
                </div>
            `;
            
            document.body.appendChild(infoPanel);
            
            // Auto-remove after 10 seconds
            setTimeout(() => infoPanel.remove(), 10000);
        }
        
        function showNeighbors() {
            const selectedNodes = cosmograph?.getSelectedNodes();
            if (!selectedNodes || selectedNodes.length === 0) {
                alert('Please select at least one node to show neighbors');
                return;
            }
            
            const neighborIds = new Set();
            
            // Find all neighbors
            selectedNodes.forEach(node => {
                const adjacentNodes = cosmograph.getAdjacentNodes(node.id);
                if (adjacentNodes) {
                    adjacentNodes.forEach(adj => neighborIds.add(adj.id));
                }
            });
            
            // Select neighbors
            const allNeighbors = Array.from(neighborIds).map(id => 
                currentData.nodes.find(n => n.id === id)
            ).filter(Boolean);
            
            cosmograph.selectNodes([...selectedNodes, ...allNeighbors]);
            console.log(`Selected ${selectedNodes.length} nodes and ${allNeighbors.length} neighbors`);
        }
        
        function focusOnSelection() {
            const selectedNodes = cosmograph?.getSelectedNodes();
            if (!selectedNodes || selectedNodes.length === 0) {
                alert('Please select nodes to focus on');
                return;
            }
            
            // Fit view to selected nodes
            const nodeIds = selectedNodes.map(n => n.id);
            cosmograph.fitViewByNodeIds(nodeIds, 500);
            
            // Optionally filter to show only selected subgraph
            console.log('Focusing on', selectedNodes.length, 'selected nodes');
        }
        
        function updateSelectionCounter() {
            const selectedNodes = cosmograph?.getSelectedNodes() || [];
            const counter = document.getElementById('selected-count');
            if (counter) {
                counter.textContent = selectedNodes.length;
            }
        }
        
        function resetPhysics() {
            if (cosmograph) {
                cosmograph.setConfig({
                    ...baseConfig,
                    simulationGravity: 0.1,
                    simulationCenter: 0.2,
                    simulationRepulsion: 1.0,
                    simulationLinkDistance: 20,
                    simulationLinkSpring: 0.5,
                    simulationDecay: 3000,
                    simulationFriction: 0.85
                });
                
                // Update UI sliders
                document.getElementById('gravity').value = 0.1;
                document.getElementById('gravity-value').textContent = '0.1';
                document.getElementById('center-force').value = 0.1;
                document.getElementById('center-force-value').textContent = '0.1';
                document.getElementById('repulsion').value = 1.0;
                document.getElementById('repulsion-value').textContent = '1.0';
                document.getElementById('friction').value = 0.85;
                document.getElementById('friction-value').textContent = '0.85';
            }
        }
    </script>
</body>
</html>