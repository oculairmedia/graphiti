#!/usr/bin/env node

import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname, basename } from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// ANSI color codes
const RED = '\x1b[31m';
const GREEN = '\x1b[32m';
const YELLOW = '\x1b[33m';
const BLUE = '\x1b[34m';
const RESET = '\x1b[0m';

// Common package locations
const PACKAGE_SOURCES = {
    'npm': 'https://registry.npmjs.org',
    'unpkg': 'https://unpkg.com',
    'jsdelivr': 'https://cdn.jsdelivr.net/npm'
};

// Known module type mappings
const MODULE_TYPES = {
    // ES modules
    'd3-array': 'esm',
    'd3-color': 'esm',
    'd3-scale': 'esm',
    'd3-selection': 'esm',
    'd3-transition': 'esm',
    'd3-ease': 'esm',
    'd3-interpolate': 'esm',
    'd3-timer': 'esm',
    'd3-dispatch': 'esm',
    'd3-drag': 'esm',
    'd3-zoom': 'esm',
    'd3-format': 'esm',
    'd3-time': 'esm',
    'd3-time-format': 'esm',
    'gl-matrix': 'esm',
    'dompurify': 'esm',
    'gl-bench': 'esm',
    
    // UMD modules that need wrappers
    'regl': 'umd',
    'crossfilter2': 'umd',
    
    // Mixed modules
    'random': 'mixed'
};

// UMD to ES module wrapper template
const UMD_WRAPPER_TEMPLATE = `// ES Module wrapper for {{MODULE_NAME}}
// Auto-generated by fix-imports.js

// Import the UMD module
import './{{MODULE_PATH}}';

// Get the global export
const globalObj = typeof window !== 'undefined' ? window : 
                 typeof self !== 'undefined' ? self : 
                 typeof global !== 'undefined' ? global : {};

// Find the exported value
const moduleExport = globalObj.{{GLOBAL_NAME}} || 
                    globalObj.{{ALT_GLOBAL_NAME}} ||
                    (globalObj.{{MODULE_NAME}} && globalObj.{{MODULE_NAME}}.{{EXPORT_NAME}});

if (!moduleExport) {
    console.warn('{{MODULE_NAME}}: Could not find expected global export');
}

// Export as default
export default moduleExport;

// Also export as named export
export { moduleExport as {{EXPORT_NAME}} };
`;

// Download a package from npm
async function downloadPackage(packageName, version = 'latest') {
    console.log(`${BLUE}Downloading ${packageName}@${version}...${RESET}`);
    
    try {
        const packageInfo = JSON.parse(
            execSync(`npm view ${packageName}@${version} --json`, { encoding: 'utf-8' })
        );
        
        const tarballUrl = packageInfo.dist.tarball;
        const vendorDir = join(__dirname, 'static', 'vendor', packageName);
        
        // Create directory
        if (!existsSync(vendorDir)) {
            mkdirSync(vendorDir, { recursive: true });
        }
        
        // Download and extract
        execSync(`curl -sL ${tarballUrl} | tar -xz -C ${vendorDir} --strip-components=1`, {
            stdio: 'inherit'
        });
        
        console.log(`${GREEN}✓${RESET} Downloaded ${packageName} to ${vendorDir}`);
        return true;
    } catch (error) {
        console.error(`${RED}✗${RESET} Failed to download ${packageName}: ${error.message}`);
        return false;
    }
}

// Create wrapper for UMD module
function createUmdWrapper(moduleName, modulePath, globalName) {
    const wrapperPath = join(__dirname, 'static', 'vendor', `${moduleName}-wrapper.js`);
    
    let content = UMD_WRAPPER_TEMPLATE
        .replace(/{{MODULE_NAME}}/g, moduleName)
        .replace(/{{MODULE_PATH}}/g, modulePath)
        .replace(/{{GLOBAL_NAME}}/g, globalName)
        .replace(/{{ALT_GLOBAL_NAME}}/g, globalName.toLowerCase())
        .replace(/{{EXPORT_NAME}}/g, globalName);
    
    writeFileSync(wrapperPath, content);
    console.log(`${GREEN}✓${RESET} Created wrapper for ${moduleName} at ${wrapperPath}`);
    
    return `/vendor/${moduleName}-wrapper.js`;
}

// Update import map in cosmograph.html
function updateImportMap(updates) {
    const htmlPath = join(__dirname, 'static', 'cosmograph.html');
    let html = readFileSync(htmlPath, 'utf-8');
    
    // Extract import map
    const importMapMatch = html.match(/<script type="importmap">([\s\S]*?)<\/script>/);
    if (!importMapMatch) {
        throw new Error('Could not find import map in cosmograph.html');
    }
    
    const importMapJson = importMapMatch[1];
    const importMap = JSON.parse(importMapJson);
    
    // Apply updates
    for (const [key, value] of Object.entries(updates)) {
        importMap.imports[key] = value;
        console.log(`${GREEN}✓${RESET} Added mapping: "${key}": "${value}"`);
    }
    
    // Sort imports for consistency
    const sortedImports = Object.keys(importMap.imports)
        .sort()
        .reduce((acc, key) => {
            acc[key] = importMap.imports[key];
            return acc;
        }, {});
    
    importMap.imports = sortedImports;
    
    // Replace in HTML
    const newImportMapJson = JSON.stringify(importMap, null, 4);
    html = html.replace(importMapMatch[0], `<script type="importmap">${newImportMapJson}</script>`);
    
    writeFileSync(htmlPath, html);
    console.log(`${GREEN}✓${RESET} Updated import map in cosmograph.html`);
}

// Fix common issues
async function fixImports() {
    console.log(`${BLUE}Import Auto-Fixer${RESET}\n`);
    
    const fixes = {};
    
    // 1. Check for missing d3 modules
    console.log(`${YELLOW}Checking d3 modules...${RESET}`);
    const d3Modules = [
        'd3-array', 'd3-color', 'd3-scale', 'd3-selection', 'd3-transition',
        'd3-ease', 'd3-interpolate', 'd3-timer', 'd3-dispatch', 'd3-drag',
        'd3-zoom', 'd3-format', 'd3-time', 'd3-time-format'
    ];
    
    for (const module of d3Modules) {
        const vendorPath = join(__dirname, 'static', 'vendor', module);
        if (!existsSync(vendorPath)) {
            if (await downloadPackage(module)) {
                fixes[module] = `/vendor/${module}/src/index.js`;
            }
        } else {
            console.log(`${GREEN}✓${RESET} ${module} already exists`);
        }
    }
    
    // 2. Fix UMD modules
    console.log(`\n${YELLOW}Checking UMD modules...${RESET}`);
    
    // regl
    const reglPath = join(__dirname, 'static', 'vendor', 'regl');
    if (existsSync(reglPath) && !existsSync(join(__dirname, 'static', 'vendor', 'regl-wrapper.js'))) {
        const wrapperPath = createUmdWrapper('regl', 'regl/dist/regl.js', 'createREGL');
        fixes['regl'] = wrapperPath;
    }
    
    // crossfilter2
    const crossfilterPath = join(__dirname, 'static', 'vendor', 'crossfilter2');
    if (existsSync(crossfilterPath) && !existsSync(join(__dirname, 'static', 'vendor', 'crossfilter2-wrapper.js'))) {
        const wrapperPath = createUmdWrapper('crossfilter2', 'crossfilter2/crossfilter.js', 'crossfilter');
        fixes['crossfilter2'] = wrapperPath;
    }
    
    // 3. Check other common packages
    console.log(`\n${YELLOW}Checking other packages...${RESET}`);
    const otherPackages = [
        { name: 'gl-matrix', path: '/vendor/gl-matrix/esm/index.js' },
        { name: 'random', path: '/vendor/random/dist/index.js' },
        { name: 'dompurify', path: '/vendor/dompurify/dist/purify.es.mjs' },
        { name: 'gl-bench', path: '/vendor/gl-bench/dist/gl-bench.module.js' }
    ];
    
    for (const pkg of otherPackages) {
        const vendorPath = join(__dirname, 'static', 'vendor', pkg.name);
        if (!existsSync(vendorPath)) {
            if (await downloadPackage(pkg.name)) {
                fixes[pkg.name] = pkg.path;
            }
        } else {
            console.log(`${GREEN}✓${RESET} ${pkg.name} already exists`);
        }
    }
    
    // 4. Update import map if there are fixes
    if (Object.keys(fixes).length > 0) {
        console.log(`\n${YELLOW}Updating import map...${RESET}`);
        updateImportMap(fixes);
        
        console.log(`\n${GREEN}✓ Fixed ${Object.keys(fixes).length} import issues!${RESET}`);
        console.log('\nRun the build script again to validate:');
        console.log('  ./build.sh');
    } else {
        console.log(`\n${GREEN}✓ No import issues found!${RESET}`);
    }
}

// Run fixer
fixImports().catch(error => {
    console.error(`${RED}Error: ${error.message}${RESET}`);
    process.exit(1);
});